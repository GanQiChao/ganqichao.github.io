{"meta":{"title":"GanQiChao's Blog","subtitle":"Tec","description":null,"author":"GanQiChao","url":""},"pages":[],"posts":[{"title":"svn 使用技巧","slug":"svn-skill","date":"2017-11-20T15:07:34.000Z","updated":"2017-11-20T15:33:53.788Z","comments":true,"path":"2017/11/20/svn-skill/","link":"","permalink":"/2017/11/20/svn-skill/","excerpt":"","text":"从事微软 C#.NET 开发12年，使用 VS 系列也12年，真正使用源代码管理工具也快10年了，现在回想起来真不知道没有使用源代码管理是怎么过来的。 记得最初使用的是 CVS 现在到没有多大印象了，后来也用了一段时间的 VSS，毕竟 VS 自带不可能没有用过吧！！不过后来新出的 VSTS 却完全没有兴趣尝试了，因为已经改用 SVN，一直到现在。 SVN 最大的体会就是一个 trunk 搞定~~！！确实是呀，虽然建立了 branches/tags，但从来不用，感觉没有必要呀，也没有去弄懂，就围绕 trunk 一直改呀改的，能用能管理就好。 直到一天，发现同时开发多个版本，噩梦就来了（不过噩梦就自己补脑吧），下面说说实际使用 SVN 的可行方案。（已实践） 众所周知，VS 是按照解决方案和项目组合而成，而项目可以依据模块呀、业务层、逻辑层等的纵向横向再纵向划分（自由发挥吧），那么当要修改某一个项目或几个项目又不想影响他人工作（担心研究性质的代码影响）怎么办呢？ 最好的解决方案是为要修改的项目创建分支，然后将具体的项目 switch 到分支上。那么有很多分支咋办，如8个呢，那就要么项目划分有问题，要么这次修改就有问题，但如果是有一个接口项目，五个实现项目，要改变接口那么 所有此接口实现五个项目就必须改啦，再有一个单元测试也要改，然后等等、等等的的项目呢？汗呀~~~~ 遇到以上情况，我只能说有必要将项目分这么细吗？引用起来不嫌弃他麻烦吗？（弱弱的说一句，貌似这是我以前曾经有过的风格，不过没有弄分支便是了，哈哈） 当然啦，也可以通过建立目录将同类型或相近的项目打包运走咯~~~注意不是临时改呀，否则等着挂吧。 tags 使用就是标记，当然要将整个解决方案标记起来，如 v1.0/v1.2。如果已经标记的版本出现 issue，那么应该用 branches v1.0-issue-12（修改那个项目就分支哪个，不要整个解决方案，获取代码可以烦死你） 来修复此 bug，修复后重新标记 tags 版本 v1.0.1，然后可以将此 issue branches 删除掉。 好了，这里就总结到这。","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"svn","slug":"svn","permalink":"/tags/svn/"},{"name":"vs2015+","slug":"vs2015","permalink":"/tags/vs2015/"}]},{"title":"jQuery 重新回顾","slug":"jQuery-review","date":"2017-11-16T14:25:16.000Z","updated":"2017-11-20T15:06:52.297Z","comments":true,"path":"2017/11/16/jQuery-review/","link":"","permalink":"/2017/11/16/jQuery-review/","excerpt":"","text":"感觉很久没有更新 jQuery 知识了，这几年都在忙工作，觉得能正常使用 jQuery 就好，遇到问题稍微检查一下源码，找到原理就可以处理，导致很多代码都是勉强处理，例如 ajax 嵌套等问题，今天抽空重新看一遍官网 api documentation 感触良多呀，印象较深的还是 Deferred Object、Callback Object，甚至连 bind() 也重新深入了解。 bind() &amp; on()1234567891011121314// 绑定多个事件$(&apos;#div1&apos;).bind(&apos;click mouseenter&apos;, function(event) &#123; alert( &quot;The &quot; + event.type + &quot; event happened!&quot; ); &#125;);$(&apos;#div1&apos;).bind(&#123; click: function () &#123; alert(&apos;click&apos;); &#125;, mouseenter: function() &#123; alert(&apos;mouseenter&apos;); &#125;&#125;);// 出入 event 数据var messager = &apos;test1&apos;;$(&apos;#div1&apos;).bind(&apos;click&apos;, &#123; msg: messager &#125;, function(event)&#123; alert(event.data.msg); &#125;);messager = &apos;msg change&apos;;$(&apos;#div1&apos;).bind(&apos;click&apos;, &#123; msg: messager &#125;, function(event)&#123; alert(event.data.msg); &#125;);// on()$(&apos;#div1&apos;).on(&apos;click&apos;, &apos;p&apos;, &#123; name: &apos;Andy&apos; &#125;, function( event ) &#123; alert(event.data.name); &#125;); trigger() &amp; triggerHandler() trigger会触发事件冒泡，而triggerHandler则不会 triggerHandler只触发jQuery对象集合中第一个元素的事件处理函数，而trigger则触发所有对象的事件处理函数 trigger会触发事件的默认行为，triggerHandler则会阻止事件的默认行为 trigger和triggerHandler都支持事件命名空间，在命名空间上的表现也完全一致 123456789101112131415161718192021222324252627// 原来可以这样传入参数$( &quot;#foo&quot; ).on( &quot;custom&quot;, function( event, param1, param2 ) &#123; alert( param1 + &quot;\\n&quot; + param2 );&#125;);$( &quot;#foo&quot;).trigger( &quot;custom&quot;, [ &quot;Custom&quot;, &quot;Event&quot; ] );// 事件命名空间$(&quot;#btn&quot;).bind(&quot;click&quot;,function()&#123; alert(&quot;no&quot;); &#125;); $(&quot;#btn&quot;).bind(&quot;click.a&quot;,function()&#123; alert(&quot;a&quot;); &#125;); $(&quot;#btn&quot;).bind(&quot;click.b&quot;,function()&#123; alert(&quot;b&quot;); &#125;); // 打印no $(&quot;#btn&quot;).trigger(&quot;click!&quot;); // 打印no,a,b $(&quot;#btn&quot;).trigger(&quot;click&quot;); // 打印a $(&quot;#btn&quot;).trigger(&quot;click.a&quot;); // 无打印 $(&quot;#btn&quot;).trigger(&quot;.a&quot;); $.Callbacks分为4种模式：once、memory、unique、stopOnFalse1$.Callbacks( &quot;unique stopOnFalse&quot; ) 观察者模式，观察者是委托、回调 .add(cb) - 添加观察者 .disable/.disabled - 禁止通知/判断是否禁止通知 .empty - 清空所有观察者 .fire(args) - 通知所有观察者，传入参数 .fireWith([context] [,args]) - 通知所有观察者，传入上下文和参数 .has(cb) - 判断是否存在观察者 .lock/locked - 不清楚用处 .remove(cb) - 取消订阅 $.Deferreddone/fail/progress 是 callbacks.add，将回调函数存入resolve/reject/notify 是 callbacks.fire，执行回调函数(或队列) 内部返回 promise 对象，避免外部控制123456789101112var wait = function()&#123; var dtd = $.Deferred(); //在函数内部，新建一个Deferred对象 var tasks = function()&#123; alert(&quot;执行完毕！&quot;); td.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd.promise(); // 返回promise对象&#125;;$.when(wait()) .done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;) .fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;); 普通操作的回调函数接口12345678910111213141516$.Deferred(wait) .done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;) .fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);var dtd = $.Deferred(); // 生成Deferred对象 var wait = function(dtd)&#123; var tasks = function()&#123; alert(&quot;执行完毕！&quot;); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000);&#125;;dtd.promise(wait);wait.done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;) .fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);wait(dtd);","categories":[],"tags":[]},{"title":"sdp 前言概要","slug":"sdp-summary","date":"2017-11-14T05:13:17.000Z","updated":"2017-11-14T13:38:53.205Z","comments":true,"path":"2017/11/14/sdp-summary/","link":"","permalink":"/2017/11/14/sdp-summary/","excerpt":"","text":"sdp 索引导航 关键字 弱关系：表示SDP各个模块间基于表示任意组合的一种关联。 上下文：表示引用和包含，也理解为父子或链式关系；上文表示引用，下文表示包含。文档中（上/下文）只是为了阅读理解，实际数据不显示。 任务转发备注说明 草稿，创建任务分配给自己，视为草稿，可填写备注，但非必要 首次转发，创建任务分配他人，不可填写备注；草稿转发他人任务，可填写备注，但非必要 非首次转发，转发他人，必须填写备注 转发自己，此情况多为任务发错，重新修改，因此必须填写备注 完结，可填写备注，非必要 sdp 索引导航","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"sdp 用词规范","slug":"sdp-word-for-standard","date":"2017-11-10T06:08:50.000Z","updated":"2017-11-11T02:41:03.766Z","comments":true,"path":"2017/11/10/sdp-word-for-standard/","link":"","permalink":"/2017/11/10/sdp-word-for-standard/","excerpt":"","text":"sdp 索引导航 获取数据CURD是一个数据库技术中的缩写词，一般的项目开发的各种参数的基本功能都是CURD。作用是用于处理数据的基本原子操作。1234检索 - retrieve # 数据源获取数据搜索 - search # 获取数据集合，关键字多个字段“或”的检索查询 - query # 获取数据集合，多个条件“并”的检索获取 - get # 获取某一个数据 功能操作分为管理型、业务型1234 #管理 #业务add | 添加 | 新建edit | 修改 | 编辑delete | 删除 | 删除 数据操作12345创建 - create # 插入新数据更新 - update # 更新已有数据检索 - retrieve # 读取数据删除 - delete # 删除已有数据保存 - save # 依赖判断主键执行创建或更新操作 常用词分为常用、备用123456789101112列表 - list分页 - pagination、pager条件 - filter、condition取消 - cancel删除 - delete、remove结果 - result详情 - delele元素 - item、el某一 - a、some组件 - componentKey - 键Value - 值 注释常用格式123456789101112131415迭代 - 元素检索 - 基于...筛选；通过...返回；转换 - 将...投影；联合 - 并循环 - 只要满足指定的条件，就会返回...排序 - 根据键按...排序判断 - 通过...确定...是否满足条件；通过...确定...是否包含...；获取 - 返回求值 - 计算委托 - 调用...返回(func)；使用指定操作...(action)属性 - 提供...；获取...；实例化 - 创建；构造函数 - 使用...初始化新的...；条件 - 如果...则...；try - 尝试 sdp 索引导航","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"DDos 防御思路","slug":"defense-ddos-idea","date":"2017-11-08T02:52:52.000Z","updated":"2017-11-11T02:41:02.969Z","comments":true,"path":"2017/11/08/defense-ddos-idea/","link":"","permalink":"/2017/11/08/defense-ddos-idea/","excerpt":"","text":"检测 ip 和 api。 思路： 数据采集 异常分析 智能优化 数据采集 黑名单 ip 过滤 ip + api 采集，可制定采集规则，后续自主学习 白名单 ip 过滤 超时 ip 资源释放监控 异常分析 监控器在时间间隔分析时间段内 ip + api 采集 提取警告 api，违反特定规则 提取异常 api，ip 超出警告限制，列入黑名单并通知管理员 智能优化 优化监控器时间间隔 优化分析时间段 建立白名单和白名单有效时间 建立黑名单和黑名单有效时间","categories":[{"name":"net","slug":"net","permalink":"/categories/net/"}],"tags":[{"name":"ddos","slug":"ddos","permalink":"/tags/ddos/"},{"name":"safe","slug":"safe","permalink":"/tags/safe/"}]},{"title":"sdp 索引导航","slug":"sdp-index","date":"2017-11-06T15:06:35.000Z","updated":"2017-11-14T13:38:52.905Z","comments":true,"path":"2017/11/06/sdp-index/","link":"","permalink":"/2017/11/06/sdp-index/","excerpt":"","text":"软件流程管理系统，简称 SDP，用于在软件研发中对资源和过程的一套自主研发的管理型系统，该系统还在完善中。 系统核心是如何结合研发管理，因此必须对研发流程的各个模块标准化，包括如何命名、如何描述、用词标准等。 以下是各个模块的链接，先占位再完善内容： 描述部分要求使用 MD 语言，这里提供部分学习链接 Markdown 语言学习 Markdown 语言学习 2 前言SDP 用词规范SDP 前言概要 Use Case - 业务用例业务用例、需求汇总文档、修改汇总文档、会议记录文档、聊天记录文档，所有由客户提出需求相关的汇总资料。 User Story - 用户故事用户故事、需求详情、修改详情，细化业务用例内容，拆分每一项内容作为独立的工作登记记录，可以理解为任务分解。 Sequence Diagram - 时序图必须结合用户故事，主要描述业务角色、业务工作和业务实体如何依据时间来协调工作，关注与职责，从而挖掘系统真实的功能。 Model Design - 原型设计名字其实 Prototype Design 更适合，管理项目启动初期，为响应需求而设计的系统原型图草稿。 System Module - 系统模块以“用”为视角，为系统设计功能菜单便于用户在需求阶段理解系统，此模块多为一级菜单，需要结合系统子模块做进一步完善。 System Sub Module - 系统子模块延续系统模块，细化一级菜单，此模块多为二级菜单，即可视的用户页面。非页面子模块需结合设计分解，但不建议在此系统子模块。 System Function - 系统功能延续系统子模块，细化用户页面，描述页面加载和功能按钮具体的作用，多为检索和提交操作，非直观可视的无需作为系统功能，如获取数据源。 Domain Model - 领域模型以“设计”为视角，结合业务知识分解核心领域，如人可分为心肺功能、神经系统等，而不是跑步。 Database Design - 数据库设计数据库引擎、ORM 技术选型、数据库命名及初始化 SQL。 Data Table - 数据库表延续数据库中数据表设计，包括字段、备注。 Communication Interface - 通讯接口前端和后端的通讯接口标准和期望正确的系统响应，约定接口输入参数和输出结果，还有验证规则要求，便于前端人员和后端人员编码一致。 Communication Scene - 通讯场景后端编码，依据不同场景下输入参数及测试数据，系统如何响应编写场景说明。 Page Code - 页面编码前端编码，依据页面可视元素和操作，编写系统操作步骤及页面说明。 Test Plan - 测试计划用于检测后端编码不同场景是否按照测试计划所设计方案正确执行。 Exception Record - 异常登记测试和编码人员提交系统存在的 BUG 以及其处理结果。","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"sdp 异常登记","slug":"sdp-exception-record","date":"2017-11-06T13:11:30.000Z","updated":"2017-11-11T02:41:02.985Z","comments":true,"path":"2017/11/06/sdp-exception-record/","link":"","permalink":"/2017/11/06/sdp-exception-record/","excerpt":"","text":"sdp 索引导航 测试和编码人员提交系统存在的 BUG 以及其处理结果。 项目 描述 标题 异常情况问题 名称 访问路由路径 描述 BUG描述：主要描述bug出现的情况界面截图：访问的界面截图测试结果：目前系统的情况描述，可以是图片或者文字期望结果：期望的情况描述，可以是图片或者文字 引用 弱关系，展示应当按照引用顺序排序 弱关系 若A与页面编码存在关系，则表示A的下文；格式为“（下文）页面编码-标题” 若A与【修改】用户故事存在关系，则表示A的下文；格式为“（下文）【修改】用户故事-标题” 若A与其他任意模块存在关系，则表示A的下文；格式为“（下文）【模块】模块名称+标题” 示例 标题：基准地价定级计算系统登录界面登录验证结果不提示 名称：/Login 描述： BUG描述：在登录的时候，没有输入密码，点击登录按钮，系统没有任何反应 界面截图：Login 测试结果：登录验证不通过没有反应 期望结果：不输入密码，输入框样式改变，警示用户不能空 引用： 【修改】用户故事-反馈意见10-27 sdp 索引导航","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"sdp 通讯场景","slug":"sdp-communication-scene","date":"2017-11-06T13:11:00.000Z","updated":"2017-11-11T02:41:02.969Z","comments":true,"path":"2017/11/06/sdp-communication-scene/","link":"","permalink":"/2017/11/06/sdp-communication-scene/","excerpt":"","text":"sdp 索引导航 后端编码，依据不同场景下输入参数及测试数据，系统如何响应编写场景说明。 项目 描述 标题 通讯场景名称，用于说明通讯场景用途，可使用对应通讯接口+序号 名称 英文表示，可使用对应通讯接口+序号 子模块 选择通讯场景所属系统子模块 接口 选择通讯场景对应通讯接口 描述 用于说明通讯场景作用 详细说明 详细说明通讯接口请求过程，包括验证内容，验证成功与否返回处理方式 输入实例 填写通讯接口所需输入参数 输出实例 根据通讯接口自动生成接口返回结构Data 部分内容，除备注外，其余不可修改 测试地址 通过选择通讯接口自动生成通讯接口请求测试地址，可修改 响应内容 点击【测试按钮】，返回通讯接口请求返回完整结构内容 引用 弱关系 描述 属性：通讯接口输入参数，根据选择通讯接口自动生成，不可修改 类型：通讯接口输入参数类型，根据选择通讯接口自动生成，不可修改 值：填写对应通讯接口输入参数值，用于测试 备注：通讯接口输入参数备注，根据选择通讯接口自动生成，可修改 示例 标题：新建定级项目 名称：ProjectCreate 子模块：定级项目管理 接口：新建定级项目 描述：用于测试新建定级项目通讯接口 详细说明： 需要验证项目名称、项目编号、专家ID集合 验证通过执行操作，返回成功信息 验证不通过不执行操作返回验证失败信息 输入实例：见《附表：输入实例》 输出实例：无 测试地址：localhost:3128/none/api//LandGradingProject/ ProjectCreate 响应内容：见《附表：响应内容》 引用：无 附表：输入实例 属性 类型 值 备注 Name string 南宁定级项目 定级项目名称 No string NN2017102901 定级项目编号 Description string 定级项目描述 ExpertIds IList [1,3] 专家ID集合 附表：响应内容 属性 值 Success true Info Data Code 200 sdp 索引导航","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"sdp 通讯接口","slug":"sdp-communication-interface","date":"2017-11-06T13:10:49.000Z","updated":"2017-11-14T13:38:52.889Z","comments":true,"path":"2017/11/06/sdp-communication-interface/","link":"","permalink":"/2017/11/06/sdp-communication-interface/","excerpt":"","text":"sdp 索引导航 前端和后端的通讯接口标准和期望正确的系统响应，约定接口输入参数和输出结果，还有验证规则要求，便于前端人员和后端人员编码一致。 项目 描述 标题 通讯接口名称，用于说明通讯接口用途 名称 英文表示，一般情况使用领域模型对应类名表示 子模块 选择通讯接口所属系统子模块 系统功能 选择通讯接口所属系统功能 数据表 用于自动生成代码，指定Execute方法中Dao类型 代码模板 用于自动生成代码选用模板，模板类型有以下5种 描述 用于表达通讯接口作用，以及通讯接口请求过程（包括验证、返回成功与否），由于返回结构固定，若需要修改返回结构，需要在此说明 输入参数 填写通讯接口所需输入参数 输出参数 填写通讯接口返回结果参数，选用代码模板后，会自动生成固定的输出参数结构 标准约束 填写通讯接口输入参数约束条件 引用 弱关系，较少场景需要使用 代码模板 Query：一般用于查询列表数据时候选用，Execute方法执行后按照固定格式返回列表内容 Get：一般用于查询单条数据时候选用，自动检验数据是否存在，Execute方法执行后返回内容 Create：一般用于创建单条新数据时候选用，Execute方法执行后不返回内容 Update：一般用于更新单条数据时候选用，自动检验数据是否存在，Execute方法执行后不返回内容 Delete：一般用于删除单条数据时候选用，自动检验数据是否存在，Execute方法执行后不返回内容 描述不要使用“当输入参数Key值不为空的时候根据输入值查询数据库字段【RecordNo】、【Address】、【Region】、【StreetName】，并返回结果”这样的说明，改为“基于Key检索备案号/地址/区域/街道”，【/】表示【或】关系，可使用【、】表示【与】关系。 输入参数 属性：英文表示，参数英文名称，使用骆驼命名法命名，首字母需大写 类型：选择属性对应的C#代码数据类型 备注：属性注释 输出参数 Success：布朗类型，表示通讯接口结果返回成功与否，结构固定部分，一般不需进行修改 Info：字符串类型，表示通讯接口结果返回信息，结构固定部分，一般不需进行修改 Data：用户定义类型，表示通讯接口返回对象，通讯接口实际返回类型在这里进行修改 Code：整型类型，表示通讯接口返回成功与否状态码，结构固定部分，一般不需进行修改 标准约束 属性：英文表示，参数英文名称，使用骆驼命名法命名，首字母需大写，对应输入参数属性名称 类型：选择属性对应的C#代码数据类型，对应输入参数属性类型 验证方式：包括非空、长度、正则表达式验证，允许多种验证方式组合使用 备注：对应验证方式的说明 示例 标题：新建定级项目 名称：ProjectCreate 子模块：定级项目管理 系统功能：新建定级项目 数据表：LandGradingProject 代码模板：Create 描述：用于保存新建定级项目 需要验证项目名称、项目编号、专家ID集合 验证通过执行操作，返回成功信息 验证不通过不执行操作返回验证失败信息 输入参数：见《附表：输入参数》 输出参数：见《附表：输出参数》 标准约束：见《附表：标准约束》 引用：无 附表：输入参数 属性 类型 备注 Name string 定级项目名称 No string 定级项目编号 Description string 定级项目描述 ExpertIds IList 专家ID集合 附表：输出参数 属性 类型 备注 Success bool 返回成功与否 Info string 返回信息 Data string 返回数据 Code int 返回状态码 附表：标准约束 属性 类型 验证方式 备注 Name string 非空 项目名称不能为空 长度（20） 项目名称在20个字符之内 No string 非空 项目编号不能为空 长度（20） 项目编号在20个字符之内 ExpertIds IList 非空 专家ID不能为空 sdp 索引导航","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"sdp 数据库表","slug":"sdp-datatable","date":"2017-11-06T13:10:30.000Z","updated":"2017-11-11T02:41:02.985Z","comments":true,"path":"2017/11/06/sdp-datatable/","link":"","permalink":"/2017/11/06/sdp-datatable/","excerpt":"","text":"sdp 索引导航 延续数据库中数据表设计，包括字段、备注。 项目 描述 标题 数据表中文名称 名称 数据库存放表名称，必须英文名称，若自定义表建议可考虑使用中文 数据库 归属数据库 描述 说明表存放数据，格式：该表用于存放…若存在外键请在此加以说明，使用MD表格格式表头：外键、关系表、关系表主键 字段 此表的字段设计 引用 弱关系，展示应当按照引用顺序排序。 弱关系 若A与【修改】业务用例存在关系，则表示A的上文；格式为“（上文）【修改】业务用例-标题”。 若A与【修改】用户故事存在关系，则表示A的上文；格式为“（上文）【修改】用户故事-标题”。 示例 标题：系统用户表 名称： SA_User 数据库： 房屋租赁备案 描述： 该表用于存放系统用户登录账号数据，派生系统管理员和注册用户 字段：见《附件：字段》 引用： 附件：字段 名称 类型 长度 非空 主键 备注 Id uniqueidentifier 36 是 是 主键 LoginName nvarchar 20 是 否 登录账号，长度不可大于20个中文 UserName nvarchar 20 是 否 用户名称，长度不可大于20个中文 LoginPassword nvarchar 255 是 否 登录密码，加密 UserState int 1 是 否 用户状态，0-启用，1-禁用 UserType int 1 是 否 用户类型，0-注册用户，1-系统管理员 Token nvarchar 255 否 否 令牌 TokenCreateTime datetime 否 否 令牌创建时间 TokenFailureTime datetime 否 否 令牌失效时间 sdp 索引导航","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"sdp 数据库设计","slug":"sdp-database-design","date":"2017-11-06T13:10:16.000Z","updated":"2017-11-11T02:41:02.985Z","comments":true,"path":"2017/11/06/sdp-database-design/","link":"","permalink":"/2017/11/06/sdp-database-design/","excerpt":"","text":"sdp 索引导航 数据库引擎、ORM 技术选型、数据库命名及初始化 SQL。 项目 描述 标题 数据库中文名称 名称 数据实例名称，英文或中文 描述 数据库引擎、ORM 技术选型 字段 此表的字段设计 引用 弱关系，展示应当按照引用顺序排序。 弱关系 若A与【需求】业务用例存在关系，则表示A的上文；格式为“（上文）【需求】业务用例-标题”。 若A与【需求】用户故事存在关系，则表示A的上文；格式为“（上文）【需求】用户故事-标题”。 若A与【修改】业务用例存在关系，则表示A的上文；格式为“（上文）【修改】业务用例-标题”。 若A与【修改】用户故事存在关系，则表示A的上文；格式为“（上文）【修改】用户故事-标题”。 示例 标题：房屋租赁备案 名称：RentRecord 描述：数据库使用 SQL Server 2008 R2 版本，第三方数据库工具使用 Simple.Data.Core、Simple.Data.Ado、Simple.Data.SqlServer 引用： sdp 索引导航","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"sdp 系统功能","slug":"sdp-system-function","date":"2017-11-06T13:09:56.000Z","updated":"2017-11-16T14:22:20.769Z","comments":true,"path":"2017/11/06/sdp-system-function/","link":"","permalink":"/2017/11/06/sdp-system-function/","excerpt":"","text":"sdp 索引导航 延续系统子模块，细化用户页面，描述页面加载和功能按钮具体的作用，多为检索和提交操作，非直观可视的无需作为系统功能，如获取数据源。 项目 描述 标题 动词 + 名称，如新建用户、编辑用户 名称 英文标识，如访问地址 系统模块 选择归属系统模块 子模块 选择归属系统子模块 描述 概述此功能实现内容，格式：主要实现…此功能在**页面，提交表单内容标准（表格） 引用 弱引用，展示应当按照引用顺序排序。 弱关系 若A与【修改】用户故事存在关系，则表示A的上文；格式为“（上文）【修改】用户故事-标题”。 示例 标题：修改个人资料 名称：Modify Personal Info 系统模块：个人信息管理 子模块：个人资料 描述： 主要实现当前登录用户修改自己的个人资料 此功能在【修改个人资料】页面，系统展示当前登录用户的个人资料，修改后提交，系统保存修改信息 个人资料信息（采用表格描述），见《附表：个人资料信息》 引用： 附表：个人资料信息 字段 选项 必填 备注 名称 是 账号 不可修改 性别 男/女 手机 是 必须手机号码 示例中可见展示个人资料作为修改个人资料的描述不单独作为系统功能，因此获取个人资料不算系统功能，但【查看个人资料】可作为系统功能，具体视业务需要 若设计时，单独有查看个人资料页面链接，然后再此页面还放置修改个人资料的按钮作为开关或链接，那么可视为两个功能。 sdp 索引导航","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"sdp 系统子模块","slug":"sdp-system-sub-module","date":"2017-11-06T13:09:49.000Z","updated":"2017-11-11T02:41:03.001Z","comments":true,"path":"2017/11/06/sdp-system-sub-module/","link":"","permalink":"/2017/11/06/sdp-system-sub-module/","excerpt":"","text":"sdp 索引导航 延续系统模块，细化一级菜单，此模块多为二级菜单，即可视的用户页面。非页面子模块需结合设计分解，但不建议在此系统子模块。 项目 描述 标题 二级菜单名称，名词作为前缀，如用户管理，不要使用“管理用户” 名称 英文标识，如访问地址 系统模块 选择归属系统模块 描述 概述此子模块实现内容，格式：主要实现… 引用 弱引用，展示应当按照引用顺序排序。 弱关系 若A与【修改】业务用例存在关系，则表示A的上文；格式为“（上文）【修改】业务用例-标题”。 若A与【修改】用户故事存在关系，则表示A的上文；格式为“（上文）【修改】用户故事-标题”。 示例 标题：用户管理 名称：User Manage 描述：主要实现用户的添加及修改，密码重置，帐号启用及停用，配置用户的角色给予相关权限。 引用： sdp 索引导航","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"sdp 系统模块","slug":"sdp-system-module","date":"2017-11-06T13:09:29.000Z","updated":"2017-11-11T02:41:02.985Z","comments":true,"path":"2017/11/06/sdp-system-module/","link":"","permalink":"/2017/11/06/sdp-system-module/","excerpt":"","text":"sdp 索引导航 以“用”为视角，为系统设计功能菜单便于用户在需求阶段理解系统，此模块多为一级菜单，需要结合系统子模块做进一步完善。 项目 描述 标题 一级菜单名称，名词作为前缀，如系统配置，不要使用“配置系统” 名称 英文标识，如访问地址 描述 概述此系统模块实现内容，格式：该模块主要实现… 引用 弱引用，展示应当按照引用顺序排序。 弱关系 若A与【修改】业务用例存在关系，则表示A的上文；格式为“（上文）【修改】业务用例-标题”。 若A与【修改】用户故事存在关系，则表示A的上文；格式为“（上文）【修改】用户故事-标题”。 示例 标题：授权管理 名称： Auth Manage 描述：该模块主要实现管理员对系统用户信息、系统角色、动物中心管理员和申请流程审核员的管理 引用： sdp 索引导航","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"sdp 原型设计","slug":"sdp-model-design","date":"2017-11-06T13:09:03.000Z","updated":"2017-11-14T13:38:53.223Z","comments":true,"path":"2017/11/06/sdp-model-design/","link":"","permalink":"/2017/11/06/sdp-model-design/","excerpt":"","text":"sdp 索引导航 名字其实 Prototype Design 更适合，管理项目启动初期，为响应需求而设计的系统原型图草稿。 项目 描述 标题 分类+界面+后缀 名称 英文 附件 具体的界面设计，主要以图片为主，可上传多个 描述 介绍界面的主要元素以及各个元素的输入格式、验证方式或者元素的点击事件可能发生的情况。描写该页面的操作，主要用于生成操作文档 引用 弱关系，展示应当按照引用顺序排序 标题 分类：如APP/WEB，非必要 界面：名词作为前缀，如用户管理列表，用户编辑 后缀：如_v1.0，非必要 引用 若A与业务用例【分类】存在关系，则表示A的下文；格式为“（下文）【分类】业务用例 + 标题” 若A被原型设计引用，则表示A的上文；格式为“（上文）【入口】原型设计 + 标题” 若A与原型设计存在关系，则表示A的下文；格式为“（下文）【出口】原型设计 + 标题” 示例 标题：WEB登录页面 名称：Login 附件：《基准地价定级计算系统登录界面》 描述： 元素描述：输入框有账户和密码，登录按钮，密码采用掩码的方式显示。 元素验证：账户和密码为必填项，统一采用提交时（登录）验证。账户若未填写账户，提示【账户不能为空】。密码若未填写密码，则提示【登录密码不能为空】。验证提示统一采用输入框样式改变的提示方式。 元素事件：登录按钮—若登录不成功，则弹出框提示用户不成功原因。登录成功直接跳转到首页。 引用： （下文）【出口】原型设计-WEB系统首页 sdp 索引导航","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"sdp 业务用例","slug":"sdp-usecase","date":"2017-11-06T13:06:49.000Z","updated":"2017-11-14T13:38:53.217Z","comments":true,"path":"2017/11/06/sdp-usecase/","link":"","permalink":"/2017/11/06/sdp-usecase/","excerpt":"","text":"sdp 索引导航 业务用例、需求汇总文档、修改汇总文档、会议记录文档、聊天记录文档，所有由客户提出需求相关的汇总资料。业务用例必须结合用户故事一起说明，本章介绍业务用例。 使用场景划分 客户提供需求资料文档客户提供具体待研发系统的需求资料，项目负责人需要按照客户提供的需求问题进行响应，这种情况下，必须以【需求】为主导开展工作（项目）。应当将严格按照需求资料内容在SDP系统详细记录，具体要求如下： 相关需求资料文档登记为一个【业务用例】，分类标记【需求】 进入研发阶段以后，客户再次提供任何资料或反馈建议，每次都必须登记为一个【业务用例】，分类标记【修改】 用户故事的标记中，【需求】和【修改】是针对资料文档每一项进行详细记录，主要目的有：响应用户需求和反馈（工作量评估）、衡量是否完成标准。 自主研发系统业务用例和用户故事以【业务】为主，基于故事开展工作（SDP、基准地价）。应当将严格按照需求资料内容在SDP系统详细记录，具体要求如下： 分析待研究组织、业务执行者和用例，则每个系统卖点登记为一个【业务用例】，分类标记【业务】，业务用例必须有具体执行者。 用户故事的【业务】是对业务用例的详细描述，必须结合现状和改进场景加以阐述。 用户故事主要目的是响应用户需求和反馈（工作量评估）、衡量是否完成标准。 协助客户共同编写需求需求人员协助客户共同对待研发系统深入研究，可以【业务】和【需求】为主导开展工作，具体有双方协商（如准备开展的土地出让项目）。此类情况按应当结合上述1、2两点开展工作。 总结业务用例和用户故事具体标记分为三类：需求、修改、业务，存在一一对应关系。需求和修改主要是为了面对客户，由系统自动生产相关响应文档《需求设计文档》，结合系统功能可另外生成《系统功能需求文档》《系统研发工作量评估》。业务主要便于研发人员从业务角度理解待研发系统在实际工作中具体起到的作用，通过现状和改进后得到体现。 需求汇总 - Requirement 项目 描述 标题 文档名称 名称 英文，【REQ】 – yyyyMMdd 业务角色 以下所有都改为分类 附件 具体资料及文档，可上传多个 需求 介绍资料背景，如获取时间、谁提供、如何获取、个人对于需求理解，以助于日后将场景还原，例如需求会议记录概要。 引用 弱关系，展示应当按照引用顺序排序。 标题 展示：分类+标题。 分类：【需求】，标题的前缀，SDP系统提供选项。 文档：后缀添加年月日yyyyMMdd，也可添加版本号_v1.0。 引用 若A与业务用例存在关系，则表示A的下文；格式为“（下文）【需求】业务用例-标题”。 若A与用户故事存在关系，则表示A的下文；格式为“（下文）【需求】用户故事-标题”。 示例 标题：【需求】基准地价定级计算系统需求20171021 名称：【REQ】- 20171021 附件：《基准地价定级计算系统需求规格说明书》 描述：2017-10-21由提供，该需求文档经过双方两次远程视频会议及多次QQ沟通。 引用：无 修改汇总 - Change进入编码阶段后，任何新需求和反馈问题全部统一视为【修改】 项目 描述 标题 文档名称，参照“业务用例【需求】，标题” 名称 英文，【CHG】 – yyyyMMdd 附件 资料文件 描述 参照“业务用例【需求】，描述” 引用 参照“业务用例【需求】，引用” 业务用例 - Use Case 项目 描述 标题 执行者+用例 执行者 与待研究组织打交道的人 待研究组织 本次系统使用的组织 用例 待研究组织的价值 名称 英文 附件 可不上传 描述 简述该用例现状。 引用 参照《业务用例【需求】》 示例 标题：【业务】评估部门获取网格点分值成果 名称：Appraisal dep get the grid point score result 附件：无 描述：因评估部门制作土地等级等价格成果图件，需要评估土地地价，现行是采用网格点价格方式，故需要从数据部门获取到网格点分值以便于计算网格点价格。 引用：无 sdp 索引导航","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"sdp 页面编码","slug":"sdp-page","date":"2017-11-06T03:11:17.000Z","updated":"2017-11-14T13:38:52.905Z","comments":true,"path":"2017/11/06/sdp-page/","link":"","permalink":"/2017/11/06/sdp-page/","excerpt":"","text":"sdp 索引导航 前端编码，依据页面可视元素和操作，编写系统操作步骤及页面说明。 项目 描述 标题 分类+界面 名称 访问路由路径 页面 页面文件放置路径 原型 选择对应的原型设计 附件 上传相关文件 描述 详细叙述页面具体元素、操作、系统响应，便于指导后续测试及系统操作手册编写 接口 页面使用到的接口，通过右边菜单选择对应的接口，与引用的使用一样。 引用 弱关系 标题 分类：如APP/WEB，非必要 界面：可于与原型设计界面一样，若需将原型分解，按照单独为页面命名 弱关系 若A被页面编码引用，则表示A的上文；格式为“（上文）【入口】页面编码 + 标题” 若A与页面编码存在关系，则表示A的下文；格式为“（下文）【出口】页面编码 + 标题” A提示和B提示说明应在原型设计加以说明。 示例 标题：WEB登录页面 名称：/Login 页面：Views/Login/Login.html 原型：WEB登录页面 附件：无 描述：填写登录信息登陆账号、登陆密码，点击【登陆】按钮 若登陆信息验证通过，则提交系统； 若登陆信息正确，则页面转向系统首页； 若登陆信息有误，则B提示错误信息： 【登陆账号不存在】 【该账号已被停用，请与管理员联系】 【登陆密码错误】 若登陆信息验证不通过，则A提示验证信息： 【登陆账号不能为空】 【登陆密码不能为空】 操作说明： 简要说明使用方式用户打开系统访问地址，进入到系统登录界面，输入账号和密码，点击登录按钮，登录成功则直接跳转到系统首页，不成功则提示用户不成功信息。 图片截已完成的完整页面 引用： （下文）【出口】页面编码-WEB系统首页 接口：见《附表：接口》 附表：接口 通讯接口 子模块 系统模块 备注 登录 登录管理 系统安全 sdp 索引导航","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"sdp 用户故事","slug":"sdp-user-story","date":"2017-11-06T03:07:28.000Z","updated":"2017-11-11T02:41:02.172Z","comments":true,"path":"2017/11/06/sdp-user-story/","link":"","permalink":"/2017/11/06/sdp-user-story/","excerpt":"","text":"sdp 索引导航 用户故事、需求详情、修改详情，细化业务用例内容，拆分每一项内容作为独立的工作登记记录，可以理解为任务分解。 需求详情 - Requirement Detail 项目 描述 标题 需求项 展示 分类+标题 分类 【需求】，标题的前缀，SDP系统提供选项 名称 英文或yyyyMMdd-01 描述 1）客户对该需求项的描述。2）需求分析师对需求的理解和响应 引用 弱关系 需求项需求文档具体的每项需求应当记录一个用户故事；另外需求分为【功能性需求】和【非功能性需求】，非功能型需求指响应时间等，建议在标题前缀添加【功能】与【非功能】标识 弱关系 若A与业务用例存在关系，则表示A的上文；格式为“（上文）【需求】业务用例-标题” 若A与用户故事存在关系，则表示A的下级；格式为“（下文）【需求】【功能】用户故事-标题” 若A与系统功能存在关系，则表示A的下级；格式为“（下文）系统功能-标题” 示例1 标题：【需求】【功能】网格点分值计算 名称：20171106-01 描述：网格点是由网格大小将定级范围划分；分值计算是由因子树、计算方式按用途（商业、住宅、办公）分别计算各种用途下每个网格点的分值；因子树是由外部ArgGis工具制作图层shp文件导入。 引用： （上文）【需求】业务用例-基准地价定级计算系统需求20171021 （下文）【需求】【功能】因子因素体系及图层管理 用户故事【需求】还存在关键字说明，如上例的因子、图层。 示例2 标题：【需求】关键字说明 名称：Keyword 描述： 因子… 因素… 图层… 引用：无 修改详情 - Change Detail 项目 描述 标题 修改项，参照“用户故事【需求】，标题”应当严格按照引用业务用例划分为【修改】 名称 英文 描述 资料文件 引用 参照“用户故事【修改】” 用户故事 - User Story 项目 描述 标题 执行者/业务工人/业务实体+场景概述 名称 英文 故事 叙述现状和改进，现状将严格依据客户当前实际情况。改进将采用步骤方式说明执行者、业务工人、业务实体和待研发系统之间是如何协调以完成工作。 引用 参照《用户故事【需求】》 标题 业务工人， 与系统直接打交道的组织内的人 业务实体， 非人，系统、时间等 场景概述，概述故事 示例 标题：【业务】数据人员计算网格点分值成果 名称：Data manager get grid point score result 描述： 数据人员建立因子树 数据人员导入图层 数据人员建立网格 数据人员提交计算方式 系统计算并记录网格点分值 数据人员下载网格点分值成果shp 引用： （上文）【业务】评估部门获取网格点分值成果 （下文）【业务】数据人员建立因子树 （下文）【业务】数据人员导入图层 （下文）【业务】数据人员建立网格 （下文）【业务】数据人员提交计算方式 （下文）【业务】系统计算并记录网格点分值 （下文）【业务】数据人员建立因子树 示例： 标题：【业务】数据人员建立因子树 名称：Data manager build factor tree 描述：（假设不存在现状，直接叙述故事步骤） 数据人员添加因素和因子 数据人员修改因素和因子 数据人员删除错误因素和因子 数据人员验证因子数据 略 引用： （上文）【业务】数据人员计算网格点分值成果 sdp 索引导航","categories":[{"name":"sdp","slug":"sdp","permalink":"/categories/sdp/"}],"tags":[{"name":"project","slug":"project","permalink":"/tags/project/"}]},{"title":"git 学习 3","slug":"git-study-3","date":"2017-11-05T15:04:15.000Z","updated":"2017-11-06T12:27:38.834Z","comments":true,"path":"2017/11/05/git-study-3/","link":"","permalink":"/2017/11/05/git-study-3/","excerpt":"","text":"远程仓库 添加远程库GitHub 注册账号并建立 repository，Clone with SSH1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; // 一路回车，使用默认值即可 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。登陆GitHub，打开“Account settings”，“SSH Keys”页面然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 首次注意事项：12345git pull origin master// 若上述命令失败，请使用一下命令git pull origin master --allow-unrelated-histories // 第一次踩雷// 可正式推送文件到远程仓库了~~！！git push -u origin master git vim 保存退出：按下 “ESC” 键，退出编辑模式，切换到命令模式，在命令模式下键入”ZZ”或者”:wq”保存修改并且退出 vi commit 若不带参数 -m 也会进入 vim 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步 从远程库克隆远程库已经准备好，用命令 git clone 克隆一个本地库$ git clone git@github.com:[ account name ]/[ repository name ]","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"Git 学习 2","slug":"git-study-2","date":"2017-11-05T13:21:11.000Z","updated":"2017-11-05T14:32:02.461Z","comments":true,"path":"2017/11/05/git-study-2/","link":"","permalink":"/2017/11/05/git-study-2/","excerpt":"","text":"本地版本库 - repository**什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 命令12345678910111213141516171819// 在目录右键选择 git bash$ git init // 初始化 git 仓库$ git add &quot;readme.txt&quot; // 添加文件到 git 仓库//$ git add &quot;r1.txt&quot; &quot;r2.txt&quot; // 添加多个文件到 git 仓库$ git commit -m &quot;wrote a readme file&quot; // 提交到仓库$ git status // 查看工作区状态$ git diff // 查看修改内容$ git add &quot;readme.txt&quot;$ git status$ git commit -m &quot;add distributed&quot;$ git add &quot;readme.txt&quot;$ git commit -m &quot;append GPL&quot;$ git log // 查看提交日记$ git log --pretty=oneline // 查看提交日记，简化信息$ git reset --hard HEAD^ // 退回一个版本，^^两个版本，~100一百个版本$ git reset --hard [commit_id] // 恢复某一提交版本$ git reflog // 查看命令历史$ git diff HEAD -- readme.txt // 查看工作区和版本库里面最新版本的区别 工作区和暂缓区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 工作区 - Working Directory电脑能看到的目录 版本库 - Repository工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。Git 的版本库里存了很多东西，其中最重要的就是称为 stage（或者叫 index）的暂存区，还有 Git 为我们自动创建的第一个分支 master，以及指向 master 的一个指针叫 HEAD。 add 命令实际是将要提交的所有修改放到暂存区（Stage），然后使用 commit 一次性把暂存区的所有修改提交到分区。 管理修改如果不 add 到暂存区，那就不会加入到 commit 中。第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit（因第二次修改没有放入暂存区，所以第二次的修改不会被提交）第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 撤销修改12$ git checkout -- readme.txt // 撤销修改$ git reset HEAD readme.txt // 提交到暂存区使用 reset 命令，然后 checkout 删除文件若 commit 删除需要还原，请使用 git reset 命令123$ git rm test.txt// 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。$ git checkout -- test.txt","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"Git 学习","slug":"git-study","date":"2017-11-05T09:19:15.000Z","updated":"2017-11-05T13:33:01.140Z","comments":true,"path":"2017/11/05/git-study/","link":"","permalink":"/2017/11/05/git-study/","excerpt":"","text":"推荐廖雪峰的官方网 Git教程 Git 的由来不多说，只有一句 Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 集中式先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 分布式那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 现状 CVS/SVNCVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。 收费除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。 VSS微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。 Git分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"Markdown 语言学习 2","slug":"markdown-course-2","date":"2017-11-02T14:39:31.000Z","updated":"2017-11-11T02:41:03.766Z","comments":true,"path":"2017/11/02/markdown-course-2/","link":"","permalink":"/2017/11/02/markdown-course-2/","excerpt":"","text":"本章主要介绍前端 MarkDown 解释脚本 showdown 的使用和坑。 git 地址 showdown.js cdn 地址 cdn showdown 1.7.6 源码 cdn showdown 1.7.6 压缩 直接上代码123456789101112function compile()&#123; // 获取要转换的文字 var text = document.getElementById(&quot;markdown&quot;).value; // 创建实例 var converter = new showdown.Converter(); // 支持表格转换 converter.setOption(&apos;tables&apos;, true); // 进行转换 var html = converter.makeHtml(text); // 展示到对应的地方 result便是id名称 document.getElementById(&quot;html-shower&quot;).innerHTML = html;&#125; git wiki 链接 Showdown Showdown Options 表格支持的大坑 一定要用两个 “–”，保证不要有空行，其他格式都不重要，为兼容考虑建议习惯“–”就好 1234| table | column | type || -- | -- | -- || User | UserName | string || Role | RoleName | string | 效果| table | column | type || – | – | – || User | UserName | string || Role | RoleName | string |","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"script","slug":"script","permalink":"/tags/script/"},{"name":"md","slug":"md","permalink":"/tags/md/"}]},{"title":"Simple.Data 关于视图使用","slug":"Simple-Data-about-view-use","date":"2017-11-02T03:51:21.000Z","updated":"2017-11-02T14:15:16.833Z","comments":true,"path":"2017/11/02/Simple-Data-about-view-use/","link":"","permalink":"/2017/11/02/Simple-Data-about-view-use/","excerpt":"","text":"Simple.Data 分页必须依赖数据表的主键，否则抛异常 AdoAdapterException 【Cannot apply paging to table with no primary key.】 基于数据查询性能考虑，我们会建立视图简化查询语句，也就是创建 view 对象，但视图是无法拥有主键，所以提出以下方案。 参考原有分页方法，为表建立排序字段 【#】123ROW_NUMBER() OVER(&#123;0&#125;) AS [_#_] // &#123;0&#125; 字段名称 + 排序// CreateTime 降序ROW_NUMBER() OVER(CreateTime desc) AS [_#_] 因此视图的建立应该指派其排序方式，分页编码使用如下：12var pageRange = (offset + 1).to(offset + limit);expression = expression.And(limit &gt; 0, () =&gt; view[&quot;_#_&quot;] == pageRange); 但此方法不可添加查询条件，否则排序结果因筛选数据而导致失效 特殊情况between and 排序功能失效，原因未能确认暂时只能使用 Linq 重新排序，要么修改 Simple.Data 分页处理，在条件后增加 order by","categories":[{"name":"database","slug":"database","permalink":"/categories/database/"}],"tags":[{"name":"Simple.Data","slug":"Simple-Data","permalink":"/tags/Simple-Data/"}]},{"title":"Simple.Data 使用建议","slug":"Simple-Data-suggest-for-use","date":"2017-10-31T12:43:42.000Z","updated":"2017-10-31T15:02:44.802Z","comments":true,"path":"2017/10/31/Simple-Data-suggest-for-use/","link":"","permalink":"/2017/10/31/Simple-Data-suggest-for-use/","excerpt":"","text":"实际使用 Simple.Data 依然存在一些问题需要注意，还有一些使用经验分析Simple.Data 使用动态类型可以忽略大小写，但建议采用 C# 规范保持首字母大写 加载关联对象数据库存在表 Node，字段有 No 和 ParentNo，No 是主键，ParentNo 是外键关联表 Node 的 No，即自身引用 定义节点 定义数据类和对象类 12345678910111213// 节点数据表类public class Node&#123; public string No &#123; get; set; &#125; // 当前节点编号 public string ParentNo &#123; get; set; &#125; // 上级节点编号&#125;// 节点对象类public class NodeObject&#123; public string No &#123; get; set; &#125; // 当前节点编号 public NodeObject Parent &#123; get; set; &#125; // 上级节点对象&#125; 检索节点 变量 db 表示数据库对象实体 1234var no = &quot;001&quot;;var getToDynamic = db.Node.Get(no); // dynamicvar getByTemplate = db.Node.Get&lt;Node&gt;(no); // dynamic，实际类型 NodeNode getToNode = db.Node.Get&lt;Node&gt;(no); // Node dynamic 类型转换 1234var nodeByStrong = (Node)getToDynamic; // 强类型转换 NodeNode nodeByDefined = getToDynamic; // 定义转换实体 Nodestring parentNo = getToDynamic.ParentNo; // dynamic 获取属性//string parentNo = nodeByStrong.ParentNo; // 实际类型获取属性 读取上级节点 12345678910111213/* 存在外键可通过表名获取 SimpleQuery，再获取数据对象 * 原理是 SimpleRecord 分析外键获取 SimpleQuery * SimpleQuery 对象使用部分命令，如：OrderBy/Select 等 * 但因存在 Where 命令，暂时为止如何使用重写 Where */var parentByDynamic = getToDynamic.Node.FirstOrDefault();var gradeParent = getToDynamic.Node.Node.FirstOrDefault(); // 待测试/* 通过上级节点对象获取编号 * 通过属性获取上级节点编号 */Assert.AreEqual(parentByDynamic.No, getToDynamic.ParentNo); // trueAssert.AreEqual(gradeParent.No, parentByDynamic.ParentNo); // true 节点对象使用 12345678910111213141516// NodeObject，可以使用 var 定义，注意不可 Get&lt;NodeObject&gt;，否则 Node 没有值dynamic nodeObject1 = db.Node.With(db.Node).Get(no);// 相当于：dynamic nodeObject1 = db.Node.WithNode().Get(no);// NodeObject，可以使用 var 或 dynamic 定义，若不使用 As 则无法赋值 ParentNodeObject nodeObject2 = db.Node.With(db.Node.As(&quot;Parent&quot;)).Get(no);/* 相当于 * dynamic node = db.Node; // 用一张表情况下建议使用变量，代码更容易理解 * NodeObject nodeObject1 = db.Node * Join(db.Node.As(&quot;Parent&quot;), out parent).On(parent.No == node.ParentNo) * //.Join(db.Node.As(&quot;Parent&quot;), out parent).On(no: node.ParentNo) * .With(parent.As(&quot;Parent&quot;)) * .Get(no); */Assert.AreEqual(nodeObject1.Node.No, nodeObject2.Parent.No)","categories":[{"name":"database","slug":"database","permalink":"/categories/database/"}],"tags":[{"name":"Simple.Data","slug":"Simple-Data","permalink":"/tags/Simple-Data/"}]},{"title":"sql 日期时间函数","slug":"sql-date-function","date":"2017-10-30T13:40:40.000Z","updated":"2017-10-30T13:55:47.082Z","comments":true,"path":"2017/10/30/sql-date-function/","link":"","permalink":"/2017/10/30/sql-date-function/","excerpt":"","text":"datediff功能： 返回两个日期之间的间隔语法： datediff ( date-path, date-expression-1, date-expression-2 )date-part： year | quarter | month | week | day | hour | minute | second | milliseconddate-part 2： yy/yyyy | qq/q | mm/m | wk/ww | dd,d | hh | mi/n | ss/s | ms | dy/y(年的某一日) getdate功能： 返回当前系统日期时间语法： getdate() day、month、year功能： 返回天、月、年 dateadd功能： 返回增加日期类型后的日期语法：dateadd ( date-part, number, date ) datepart功能：返回指定日期类型的值，等同于 day()、month()、year()语法：datapart ( date-part, date)","categories":[{"name":"database","slug":"database","permalink":"/categories/database/"}],"tags":[{"name":"collect","slug":"collect","permalink":"/tags/collect/"},{"name":"sql","slug":"sql","permalink":"/tags/sql/"}]},{"title":"Simple.Data 检索数据（2）","slug":"Simple-Data-Select-2","date":"2017-10-30T12:15:19.000Z","updated":"2017-11-05T09:07:14.822Z","comments":true,"path":"2017/10/30/Simple-Data-Select-2/","link":"","permalink":"/2017/10/30/Simple-Data-Select-2/","excerpt":"","text":"Simple.Data 利用 .NET 4.0 动态类型技术 dynamic，令此对象支持想要的任何特性，如果使用过的脚本语言这样的写法就并不陌生（javascript、python），可简化类型转换代码，而且允许直接使用索引方式访问属性。 Simple.Data 主要常用类型有 名称 缩写 说明 DynamicStrategy DS 数据库 DynamicTable DT 数据表 SimpleQuery SQ 查询 SimpleExpression SE 条件表达式 SimpleRecord SR 记录 SimpleList SL 记录列表 ObjectReference OR 对象引用，DS.DT、DT.Field 都可转换为此对象 查询、关联、合计、函数 - Query、Join、Aggregate、Function 命令 参数 返回 说明 Select OR[] SQ 指定返回查询字段数据 Star/AllColumns null SQ 用于 Table，返回表所有字段数据 Distinct null SQ 用于 Column，过滤相同数据 As str OR 用于 Table、Column，设置列别名 Where SE SQ 更新标准 Operators 用于 Column，二元操作符+、-、*、/、%、==、!=、&lt;、&lt;=、&gt;、&gt;= In obj[] OR 用于 Column，in 语法 Between num OR 用于 Column，两个数值之间 1.to(20)，也支持日期 Like str OR 用于 Column，模糊条件 is null 用于 Column，查询空值 OrderBy OR SQ 升序 OrderByDescending OR SQ 降序 ThenBy OR SQ 升序，OrderBy 后面使用 ThenByDescending OR SQ 降序，OrderBy 后面使用 Natural Join 外键关联 Join DT SQ Join On Left Join DT SQ LeftJoin On With DT SQ eager-loaded，单个或多个记录 WithOne DT SQ eager-loaded，单个记录 WithMany DT SQ eager-loaded，多个记录 Having SE OR 用于 Column，Function 查询标准条件 Min null OR 用于 Column，最小值 Max null OR 用于 Column，最大值 Avg null OR 用于 Column，平均值 Sum null OR 用于 Column，合计 Count null OR 用于 Column，数量 CountDistinct null OR 用于 Column，过滤重复后的数量 Length null OR 用于 Column，字符长度 ToScalar null object 获取第一行第一列 ToScalarList null IList&lt;&gt; 获取所有行第一列 ToScalarArray null object[] 获取所有行第一列 ToScalarOrDefault null object 获取第一行第一列或默认 Implicit Casting 强类型转换，可直接赋值给予定义变量 Cast IEnumerable 强类型转换 ToList IList 获取数据对象列表 ToList IList 获取数据对象列表 ToArray dynamic[] 获取数据对象数组，遍历速度高于列表 ToArray IList 获取数据对象数组 Skip int SQ 忽略记录数量 Take int SQ 提取记录数量 WithTotalCount SQ 记录总数 First SQ 获取第一行数据 FirstOrDefault SQ 获取第一行数据或 null Single SQ 获取第一行数据 SingleOrDefault SQ 获取第一行数据或 null","categories":[{"name":"database","slug":"database","permalink":"/categories/database/"}],"tags":[{"name":"Simple.Data","slug":"Simple-Data","permalink":"/tags/Simple-Data/"}]},{"title":"Simple.Data 介绍、检索数据（1）","slug":"Simple-Data-Select","date":"2017-10-29T13:57:14.000Z","updated":"2017-11-02T15:11:04.891Z","comments":true,"path":"2017/10/29/Simple-Data-Select/","link":"","permalink":"/2017/10/29/Simple-Data-Select/","excerpt":"","text":"接触 ORM 至今为止，从最初的 NHibernate、Castle、EF 相对强大的类库，到现在使用的“很黄很暴力”的 Simple.Data，已经有10年的时间。而 ORM 之前基本都是写一句 SQL 语句查询返回 DataSet（.NET），后来在此基础上增加数据访问层 Dao 来封装，再进一步返回业务对象。现在感触最深的还是回归到可控性最强的 SQL 但无法避免返回 DataSet 问题（虽然可以用 Reader解决），而 Simple.Data 可以牺牲一定可控性的基础上换取便利的对象操作。 安装 要求 .NET 4.0 或以上 使用 nuget 搜索 simple.data.core（核心库） 根据数据库引擎需要，在主项目使用 nuget 搜索 simple.data.sqldata（mysql/oracle），安装过程同时自动安装 simple.data.adoadapter 检索数据 - retrieve data标准类型 SimpleExpression(SE)，返回 SimpleQuery(SQ) 可以通过迭代 SimpleRecord(SR) 集合获取结果数据对象，此对象为 dynamic 类型，可使用强类型转换为期望类型或 IDictionary。 dynamic 类型优点在于允许直接访问属性（列名） result.ColumnName，也可以通过索引访问 result[“ColumnName”]（记得可以的，若不行则需要强类型转换 IDictionar。 若数据存在外键，还允许在 SE 通过外键表名称直接写条件，如 table.Topic.Title.Like(“%我的心得%”)，避免繁琐的 Join On。 当然，据目前使用过程还发现一些 Bug 存在两个或以上的外键指向同一张表，SE 只建立最后一个外键（字段顺序也可能是外键顺序，但不确认），建议出现此类情况还是使用 JOIN ON 来解决 ToFirstOrDefault 导致从表仅返回第一条数据，建议使用 Find 或延迟加载从表数据 Skip 且没有 Where 引起分页条件位置不正确，导致数据分页查询返回结果不正确，建议增加默认条件 WithTotalCount 返回属性含有集合对象Bug，原因未明，建议尽量不要返回集合数据对象，改用 Select 优化，如无法避免则建议使用 dynamic 延迟加载集合对象。 Simple.Data 主要常用类型有 名称 缩写 说明 DynamicStrategy DS 数据库 DynamicTable DT 数据表 SimpleQuery SQ 查询 SimpleExpression SE 条件表达式 SimpleRecord SR 记录 SimpleList SL 记录列表 ObjectReference OR 对象引用，DS.DT、DT.Field 都可转换为此对象 命令 参数 返回 说明 All SE SQ 返回表所有数据 FindAll SE SQ 通过标准返回表数据 FindAllBy OR[] SQ 通过列名和值返回表数据 Find SE SR 通过标准返回一条表数据，若查询到多条只返回第一条 Get o[] SR 通过主键返回一条表数据 GetCount SE int 通过标准返回表数据数量 GetCountBy str int 通过列名和值返回表数据数量 Exists/Any SE bool 通过标准返回是否存在表数据 ExistsBy/AnyBy str bool 通过列名和值返回是否存在表数据数量 其他注意问题 Query、QueryBy：已过时，请使用 All、FindAllBy FindBy：已过时，请使用 FindAllBy.FirstOrDefault() 或 Get SimpleQuery：可以使用迭代或 ToList、ToFirstOrDefault、ToScalar 等 Linq 相似的方法或数据对象","categories":[{"name":"database","slug":"database","permalink":"/categories/database/"}],"tags":[{"name":"Simple.Data","slug":"Simple-Data","permalink":"/tags/Simple-Data/"}]},{"title":"HBuilder svn 插件安装","slug":"HBuilder-svn-plugin","date":"2017-10-28T14:57:54.000Z","updated":"2017-11-02T14:41:27.994Z","comments":true,"path":"2017/10/28/HBuilder-svn-plugin/","link":"","permalink":"/2017/10/28/HBuilder-svn-plugin/","excerpt":"","text":"安装步骤 工具 &gt;&gt; 插件安装 选择 SVN &gt;&gt; 安装，重启 HBuilder 工具 &gt;&gt; 插件安装 &gt;&gt; 手动安装插件（SVN 版本问题，必须更新版本） Work with： http://subclipse.tigris.org/update_1.10.x 全部保存，一直点击【下一步】，最后【完成】，重启 Hbuilder 视图 &gt;&gt; 定制透视图 命令和快捷方式选项卡勾选 SVN，tool bar 和 menu 勾选 SVN 确定后，安装完毕","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"mobile","slug":"mobile","permalink":"/tags/mobile/"},{"name":"plugin","slug":"plugin","permalink":"/tags/plugin/"}]},{"title":"javascript 继承收集","slug":"javascript-inherit-collect","date":"2017-10-27T05:52:23.000Z","updated":"2017-11-02T14:45:39.950Z","comments":true,"path":"2017/10/27/javascript-inherit-collect/","link":"","permalink":"/2017/10/27/javascript-inherit-collect/","excerpt":"","text":"定义父类12345678910111213// 定义一个动物类function Animal (name) &#123; // 属性 this.name = name || &apos;Animal&apos;; // 实例方法 this.sleep = function()&#123; console.log(this.name + &apos; 正在睡觉！&apos;); &#125;;&#125;// 原型方法Animal.prototype.eat = function(food) &#123; console.log(this.name + &apos; 正在吃：&apos; + food);&#125;; 推荐继承直接贴代码12345678910111213141516171819202122232425262728293031323334353637383940414243// 继承function inherit(superConstructor, subConstructor) &#123; var proto = beget(superConstructor.prototype); // 核心 proto.constructor = subConstructor; // 修改构造函数 subConstructor.prototype = proto; // 修改原型链，将实例作为子类的原型&#125;;function beget(obj) &#123; var F = function () &#123;&#125;; F.prototype = obj; return new F();&#125;function Cat(name) &#123; Animal.call(this, name); // 调用父类构造函数，创建属性和实例方法 this.base = this.__proto__.__proto__; // 定义基类对象 this.color = &apos;white&apos;; // 重载实例方法，也可以使用原型方法重载 this.sleep = function(fav) &#123; if (fav) &#123; console.log(this.name + &apos; 最喜欢在&apos; + fav + &apos;睡觉&apos;); &#125; else &#123; this.base.sleep.call(this); // 注意这里是调用基类方法，使用 call 改变调用对象 &#125; &#125;&#125;inherit(Animal, Cat); // Cat 继承 Animal// 重载原型方法，必须在继承后Cat.prototype.eat = function(food, fav)&#123; if (fav) &#123; console.log(this.name + &apos; 最喜欢的食物是：&apos; + food); &#125; else &#123; this.base.eat.call(this, food); // 调用基类方法，使用 call 或 apply // this.base.eat.apply(this, arguments); &#125;&#125;var cat = new Cat(&apos;Tom cat&apos;);cat.eat(&apos;fish&apos;, true); // cat 最喜欢的食物是：fishcat.eat(&apos;fish&apos;); // cat 正在吃：fishconsole.log(typeof cat.sleep === &apos;function&apos;); // true, 实例方法无法继承 继承可使用上述代码实现，如需详细了解其他方式可见下文。 ========== 分界线 =========== 原型链继承核心： 将父类的实例作为子类的原型123456789101112function Cat()&#123; &#125;Cat.prototype = new Animal();Cat.prototype.name = &apos;cat&apos;;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.eat(&apos;fish&apos;));console.log(cat.sleep());console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); // true 问题： 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 构造继承核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）1234567891011function Cat(name)&#123; Animal.call(this); this.name = name || &apos;Tom&apos;;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 问题： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 实例继承核心：为父类实例添加新特性，作为子类实例返回123456789101112function Cat(name)&#123; var instance = new Animal(); instance.name = name || &apos;Tom&apos;; return instance;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 问题： 实例是父类的实例，不是子类的实例 不支持多继承 拷贝继承1234567891011121314function Cat(name)&#123; var animal = new Animal(); for(var p in animal)&#123; Cat.prototype[p] = animal[p]; &#125; Cat.prototype.name = name || &apos;Tom&apos;;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 问题： 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 组合继承核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用123456789101112function Cat(name)&#123; Animal.call(this); this.name = name || &apos;Tom&apos;;&#125;Cat.prototype = new Animal();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 问题： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 寄生组合继承(实现复杂)核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点123456789101112131415161718function Cat(name)&#123; Animal.call(this); this.name = name || &apos;Tom&apos;;&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"collect","slug":"collect","permalink":"/tags/collect/"},{"name":"script","slug":"script","permalink":"/tags/script/"},{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Grunt jshint 配置","slug":"grunt-jshint-options","date":"2017-10-27T04:45:52.000Z","updated":"2017-11-02T14:41:08.784Z","comments":true,"path":"2017/10/27/grunt-jshint-options/","link":"","permalink":"/2017/10/27/grunt-jshint-options/","excerpt":"","text":"jsHint 同 jsLint 一样都是 js 代码检查工具 jsHint 规则 参考资料http://www.cnblogs.com/code/articles/4103070.htmlhttp://www.htmlhifive.com/conts/web/view/library/JSLint_JSHint bitwise1// 禁用位运算符(如^，&amp;) curly1// if 和 while 等语句中使用&#123;&#125;来明确代码块 eqeqeq1// 使用 === 和 !== 替代 == 和 != forin1// 在 for in 循环中使用 Object.prototype.hasOwnProperty() 来过滤原型链中的属性 immed123456789// 匿名函数调用必须(function() &#123; // body &#125;());// 而不是(function() &#123; // body&#125;)();// 这是为了表明，表达式的值是函数的结果，而不是函数本身。 latedef1// 变量定义前禁止使用 newcap1// 构造函数名首字母必须大写 noarg1// 禁止使用arguments.caller和arguments.callee noempty1// 禁止出现空的代码块 nonew1// 禁止使用构造器 plusplus1// 禁止使用++和-- undef1// 禁止使用不在全局变量列表中的未定义的变量 strict1// 强制使用ES5的严格模式 freeze1234// 禁止复写原生对象(如Array, Date)的原型/* jshint freeze:true */Array.prototype.count = function (value) &#123; return 4; &#125;;// -&gt; Warning: Extending prototype of native object: &apos;Array&apos;. asi1// 允许省略分号 boss1// 允许在if，for，while语句中使用赋值;在条件语句中使用赋值经常是笔误if (a = 10) &#123;&#125; debug1// 允许debugger语句 eqnull12// 允许==null// ==null通常用来比较=== null;=== undefined evil1// 允许使用eval expr1// 允许应该出现赋值或函数调用的地方使用表达式 iterator12// 允许__iterator__;// 不是所有的浏览器都支持__iterator__。 lastsemic12// 允许单行控制块省略分号var name = (function() &#123; return &apos;Anton&apos; &#125;()); laxbreak1// 允许不安全的行中断(与laxcomma配合使用) laxcomma1// 允许逗号开头的编码样式 loopfunc1// 允许循环中定义函数 onecase1// 允许只有一个case条件的switch语句吗 proto1// 允许 proto（不是所有的浏览器都支持__proto__.） regexdash1// 在正则表达式的控制语句，连字符开头或方括号的结束 - 容忍的存在。 scripturl1// 允许 javascript:; shadow1234567891011// 允许变量shadowfunction test() &#123; var x = 10; if (true) &#123; var x = 20; &#125; return x;&#125;// 基于“函数作用域”，多次定义变量和单次定义是没有区别的，但是会造成阅读障碍。 sub12// 允许person[‘name’]// JSHint推荐使用 person.name 代替 person[‘name’] supernew1// 允许new function() &#123;…&#125;和new Object; validthis1// 允许严格模式下在非构造函数中使用this","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"plugin","slug":"plugin","permalink":"/tags/plugin/"},{"name":"grunt","slug":"grunt","permalink":"/tags/grunt/"},{"name":"script","slug":"script","permalink":"/tags/script/"}]},{"title":"Markdown 语言学习","slug":"markdown-course","date":"2017-10-26T14:17:29.000Z","updated":"2017-11-02T14:40:22.120Z","comments":true,"path":"2017/10/26/markdown-course/","link":"","permalink":"/2017/10/26/markdown-course/","excerpt":"","text":"Markdown 的目标是实现「易读易写」。 Markdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强。 建议使用缩进表示归属上一层级，如果出现块情况非空行不能处理归属问题 标题123456H1 :# Header 1H2 :## Header 2H3 :### Header 3H4 :#### Header 4H5 :##### Header 5H6 :###### Header 6 H1 :# Header 1H2 :## Header 2H3 :### Header 3H4 :#### Header 4H5 :##### Header 5H6 :###### Header 6 文本样式123456789101112（带“*”星号的文本样式，在原版 Markdown 标准中不存在，但在其大部分衍生标准中被添加）链接 :[Title](URL)加粗 :**Bold**斜体字 :*Italics**删除线 :~~text~~*高亮 :==text==段落 : 段落之间空一行换行符 : 一行结束时输入两个空格列表 :* 添加星号成为一个新的列表项。引用 :&gt; 引用内容内嵌代码 : `alert(&apos;Hello World&apos;);`画水平线 (HR) :-------- 链接 :Title加粗 :Bold斜体字 :Italics删除线 :text 高亮 :==text==段落 : 段落之间空一行换行符 : 一行结束时输入两个空格列表 :* 添加星号成为一个新的列表项。引用 :&gt; 引用内容内嵌代码 : alert(&#39;Hello World&#39;);画水平线 (HR) :——– 图片1![Title](src). 写代码1连续3个【`】闭合，闭合部分写入代码 HTML 代码在 HTML 区块标签间的 Markdown 格式语法将不会被处理。处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换 符号 输入 &amp; &amp;amp; &gt; &amp;gt; &lt; &amp;lt; 区块引用 Blockquotes12345678&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt;&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing.&gt;&gt; Back to the first level. This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. Back to the first level. 列表12345无序列表使用星号、加号或是减号作为列表标记* Red // eq: + Red - Red* Green Light* Blue Red GreenLight Blue 123456有序列表则使用数字接着一个英文句点很重要的一点是，列表标记上使用的数字并不会影响输出的 HTML 结果为未来考虑，建议保留顺序1. Bird2. McHale3. Parish Bird McHale Parish 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;p&gt; 标签包起来123* Bird* Magic 当然，项目列表很可能会不小心产生，像是下面这样的写法：11986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。11986\\. What a great season. 表格12345| Tables | Col | Type || ------------- |:-------------:| -----:|| SA_User | Type | int || SA_Role | RoleName | char || SA_UserRole | UserId | 1 | Tables Col Type SA_User Type int SA_Role RoleName char SA_UserRole UserId 1 自动链接12一般网址的链接文字就和链接地址一样&lt;http://example.com/&gt; 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），可以在星号的前面加上反斜杠：1\\*literal asterisks\\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"script","slug":"script","permalink":"/tags/script/"},{"name":"md","slug":"md","permalink":"/tags/md/"}]},{"title":"YMAL 语言学习","slug":"yaml-course","date":"2017-10-26T14:17:21.000Z","updated":"2017-11-02T14:42:44.424Z","comments":true,"path":"2017/10/26/yaml-course/","link":"","permalink":"/2017/10/26/yaml-course/","excerpt":"","text":"参考：阮一峰的网络日志 - YAML 语言教程 YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便，也类似于标准通用标记语言的子集XML的数据描述语言，语法比XML简单很多。 YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。 基本语法 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可1# 表示注释，从这个字符一直到行尾，都会被解析器忽略。 数据结构 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 比对 YAML 和 JavascriptYAML 转换 Javascript 对象的一组键值对，使用冒号结构表示。 12345animal: petsout~ &#123; animal: &apos;pets&apos; &#125;# 行内对象hash: &#123; name: Steve, foo: bar &#125;out~ &#123; hash: &#123; name: &apos;Steve&apos;, foo: &apos;bar&apos; &#125; &#125; 一组连词线开头的行，构成一个数组。 12345678910111213- Cat- Dog- Goldfishout~ [ &apos;Cat&apos;, &apos;Dog&apos;, &apos;Goldfish&apos; ]# 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。- - Cat - Dog - Goldfishout~ [ [ &apos;Cat&apos;, &apos;Dog&apos;, &apos;Goldfish&apos; ] ]# 行内表示法animal: [Cat, Dog]out~ &#123; animal: [ &apos;Cat&apos;, &apos;Dog&apos; ] &#125; 对象和数组可以结合使用，形成复合结构 123456789languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 123456&#123; languages: [ &apos;Ruby&apos;, &apos;Perl&apos;, &apos;Python&apos; ], websites: &#123; YAML: &apos;yaml.org&apos;, Ruby: &apos;ruby-lang.org&apos;, Python: &apos;python.org&apos;, Perl: &apos;use.perl.org&apos; &#125; &#125; 纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。 字符串 - 字符串默认不使用引号表示。 布尔值 - 布尔值用true和false表示 整数 - 数值直接以字面量的形式表示 浮点数 Null - # null用~表示 时间 - 时间采用 ISO8601 格式 日期 - 日期采用复合 iso8601 格式的年、月、日表示。 使用两个感叹号，强制转换数据类型 12e: !!str 123f: !!str true 字符串字符串是最常见，也是最复杂的一种数据类型。 123# 字符串默认不使用引号表示。str: 这是一行字符串out~ &#123; str: &apos;这是一行字符串&apos; &#125; 123# 如果字符串之中包含空格或特殊字符，需要放在引号之中。str: &apos;内容： 字符串&apos;out~ &#123; str: &apos;内容: 字符串&apos; &#125; 1234# 单引号和双引号都可以使用，双引号不会对特殊字符转义。s1: &apos;内容\\n字符串&apos;s2: &quot;内容\\n字符串&quot;out~ &#123; s1: &apos;内容\\\\n字符串&apos;, s2: &apos;内容\\n字符串&apos; &#125; 123# 单引号之中如果还有单引号，必须连续使用两个单引号转义。str: &apos;labor&apos;&apos;s day&apos;out~ &#123; str: &apos;labor\\&apos;s day&apos; &#125; 12345# 字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。str: 这是一段 多行 字符串out~ &#123; str: &apos;这是一段 多行 字符串&apos; &#125; 12345678# 多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行。this: | Foo Barthat: &gt; Foo Barout~ &#123; this: &apos;Foo\\nBar\\n&apos;, that: &apos;Foo Bar\\n&apos; &#125; 1234567891011# +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。s1: | Foos2: |+ Foos3: |- Fooout~ &#123; s1: &apos;Foo\\n&apos;, s2: &apos;Foo\\n\\n\\n&apos;, s3: &apos;Foo&apos; &#125; 1234567# 字符串之中可以插入 HTML 标记。message: | &lt;p style=&quot;color: red&quot;&gt; 段落 &lt;/p&gt;out~ &#123; message: &apos;\\n&lt;p style=&quot;color: red&quot;&gt;\\n 段落\\n&lt;/p&gt;\\n&apos; &#125; 引用锚点&amp;和别名*，可以用来引用 1234567891011defaults: &amp;defaults adapter: postgres host: localhostdevelopment: database: myapp_development &lt;&lt;: *defaultstest: database: myapp_test &lt;&lt;: *defaults &amp;用来建立锚点（defaults），&lt;&lt;表示合并到当前数据，*用来引用锚点。等同于 12345678910111213defaults: adapter: postgres host: localhostdevelopment: database: myapp_development adapter: postgres host: localhosttest: database: myapp_test adapter: postgres host: localhost 另一种写法： 12345- &amp;showell Steve - Clark - Brian - Oren - *showell 等同于 1[ &apos;Steve&apos;, &apos;Clark&apos;, &apos;Brian&apos;, &apos;Oren&apos;, &apos;Steve&apos; ]","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"script","slug":"script","permalink":"/tags/script/"},{"name":"ymal","slug":"ymal","permalink":"/tags/ymal/"}]},{"title":"hexo themes (2)","slug":"hexo-themes-2","date":"2017-10-25T15:03:48.000Z","updated":"2017-11-02T14:42:02.210Z","comments":true,"path":"2017/10/25/hexo-themes-2/","link":"","permalink":"/2017/10/25/hexo-themes-2/","excerpt":"","text":"安装模板遇到的问题网络安装模块因网络原因导致失败，也有可能是资源已经关闭（可能性不高） themes/.config.yml每个模板都会有自己的配置，与博客自己的 _config.yml 不一样，此配置文件只对模板起作用，因不了解，导致 less 生成 css 文件失败 .config.yml1languages: zh-CN # 使用不存在的语言 zh，导致内部调用 ca themes/languages因配置错误语言，发现 ejs 具体调用语言方法，具体待进一步去学习1__(&apos;index.category&apos;) # 估计是读取 languages yml 配置的 index.category 变量值 node_modules模块脚本等资源都可以直接修改，因发现 hexo-asset-image 模块生产图片路径有误，直接修改 index.js 文件处理脚本部分问题后，可正确输出图片 多级 categories在 md 文件的 categories 写入数组，将按照数组顺序建立层级关系1234categories: # parent &gt;&gt; child &gt;&gt; tail - parent - child - tail","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"theme","slug":"theme","permalink":"/tags/theme/"}]},{"title":"一张图简述 MIT 等协议","slug":"about-license-for-simple","date":"2017-10-25T14:08:27.000Z","updated":"2017-11-02T14:45:11.530Z","comments":true,"path":"2017/10/25/about-license-for-simple/","link":"","permalink":"/2017/10/25/about-license-for-simple/","excerpt":"","text":"License世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种—-GPL、BSD、MIT、Mozilla、Apache和LGPL—-之中做选择，也很复杂，这张图比那种一堆文字要简单易懂的多 引用：如何选择开源许可证？","categories":[{"name":"license","slug":"license","permalink":"/categories/license/"}],"tags":[{"name":"collect","slug":"collect","permalink":"/tags/collect/"}]},{"title":"hexo theme","slug":"hexo-themes","date":"2017-10-25T03:53:52.000Z","updated":"2017-11-02T14:41:57.100Z","comments":true,"path":"2017/10/25/hexo-themes/","link":"","permalink":"/2017/10/25/hexo-themes/","excerpt":"","text":"官网提供的模板模板地址 hexo themes，点击图片可以预览效果，点击文字可以进入 git下面列举示例，引用 hexo-theme-bootstrap-blog 安装主题必须在 hexo 2.4 或以上 将主题拉到本地: 1$ git clone https://github.com/cgmartin/hexo-theme-bootstrap-blog.git themes/bootstrap-blog 安装 hexo-tag-bootstrap for more Bootstrap tags (textcolors, buttons, labels, badges, etc.): 1$ npm install hexo-tag-bootstrap --save 安装 hexo-tag-fontawesome for placing Font Awesome icons in your Markdown: 1$ npm install hexo-tag-fontawesome --save 修改脚本引用因 google 国内无法访问，打开 themes/bootstrap-blog/layout/_partial/inline-scripts.ejs，将 jQuery 和 bootstrap 引用修改： 123&lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 配置 _config.yml 的 theme 配置 1234theme: hexo-theme-xups# 更新 git$ cd themes/bootstrap-blog$ git pull","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"theme","slug":"theme","permalink":"/tags/theme/"}]},{"title":"hexo 安装","slug":"hexo-install","date":"2017-10-25T03:05:14.000Z","updated":"2017-11-02T14:41:43.329Z","comments":true,"path":"2017/10/25/hexo-install/","link":"","permalink":"/2017/10/25/hexo-install/","excerpt":"","text":"hexo 环境node.js &amp; npm到官网下载最新安装包 node.js，已经包括 node.js 和 npm，默认安装便可 git到官网下载最新安装包 git，安装后一定要重启，否则 git 无法作为全局命令使用（弄了N次环境变量都不行，结果重启一下就好了，晕死） hexo 直接给命令12345$ npm install hexo-cli -g # 作为全局命令安装 hexo $ hexo init blog # 通过 cd 命令选定目录后初始化建立 blog$ cd blog # 进入 blog 目录$ npm install # 还原 npm 引用$ hexo server # 启动 hexo 服务，默认4000端口 发布 git 静态页面 配置github账户信息 12$ git config --global user.name &quot;YourName&quot; $ git config --global user.email &quot;YourEmail&quot; SSH进入 blog 所在目录，右键打开“Git Bash Here” 1234$ ssh-keygen -t rsa -C &quot;youremail&quot; # 第一个提示信息是 .ssh 目录，直接回车 # 第二、三个提示是输入密匙，两次一致便可$ cd ~/.ssh # 进入 SSH 目录$ cat id_rsa.pub # SSH 密匙，复制并在 git 上面添加（注意不要复制最后的邮件地址） git 配置在参考 hexo从零开始到搭建完整 及个人博客 首个博客","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"install","slug":"install","permalink":"/tags/install/"}]},{"title":"首个博客","slug":"first-blog","date":"2017-10-24T15:11:14.000Z","updated":"2017-11-02T15:04:36.939Z","comments":true,"path":"2017/10/24/first-blog/","link":"","permalink":"/2017/10/24/first-blog/","excerpt":"","text":"首次发布个人博客尝试学习 node.js 搭建服务端，学习 hexo + node.js 开源项目创建个人博客，初步了解该项目使用技术有 技术 介绍 node.js 一个Javascript运行环境(runtime)；Node.js 使用事件驱动，非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 git 分布式版本控制系统 YAML _config.yml另一种标记语言，它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。 ejs EJS是一个JavaScript模板库，用来从JSON数据中生成HTML字符串。 md Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 终于成功搭建 hexo坑坑坑….. 稍微总结一下 hexo 搭建遇到的问题 搭建了两个网站，结果配置 _config.yml 的 deploy 搞混了 顺带说明一下变量和值之间的冒号“:”必须在冒号后添加一个空格，语法要求 创建 SSH 命令注意要大小写匹配安装 1$ ssh-keygen -t rsa -C &quot;youremail&quot; # 配置 ssh 安装 hexo-deployer-git 若失败或提示忽略这忽略那，建议删除 node_modules 目录，重新执行 npm install 12$ npm install hexo-deployer-git --save$ npm install 下一步掌握 _config.yml 配置文件及安装 themes","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"/tags/blog/"}]}]}