{"meta":{"title":"GanQiChao's Blog","subtitle":"Tec","description":null,"author":"GanQiChao","url":""},"pages":[],"posts":[{"title":"sql 日期时间函数","slug":"sql-date-function","date":"2017-10-30T13:40:40.000Z","updated":"2017-10-30T13:55:47.082Z","comments":true,"path":"2017/10/30/sql-date-function/","link":"","permalink":"/2017/10/30/sql-date-function/","excerpt":"","text":"datediff功能： 返回两个日期之间的间隔语法： datediff ( date-path, date-expression-1, date-expression-2 )date-part： year | quarter | month | week | day | hour | minute | second | milliseconddate-part 2： yy/yyyy | qq/q | mm/m | wk/ww | dd,d | hh | mi/n | ss/s | ms | dy/y(年的某一日) getdate功能： 返回当前系统日期时间语法： getdate() day、month、year功能： 返回天、月、年 dateadd功能： 返回增加日期类型后的日期语法：dateadd ( date-part, number, date ) datepart功能：返回指定日期类型的值，等同于 day()、month()、year()语法：datapart ( date-part, date)","categories":[{"name":"database","slug":"database","permalink":"/categories/database/"}],"tags":[{"name":"collect","slug":"collect","permalink":"/tags/collect/"},{"name":"sql","slug":"sql","permalink":"/tags/sql/"}]},{"title":"Simple.Data 检索数据（2）","slug":"Simple-Data-Select-2","date":"2017-10-30T12:15:19.000Z","updated":"2017-10-30T13:39:36.377Z","comments":true,"path":"2017/10/30/Simple-Data-Select-2/","link":"","permalink":"/2017/10/30/Simple-Data-Select-2/","excerpt":"","text":"Simple.Data 利用 .NET 4.0 动态类型技术 dynamic，令此对象支持想要的任何特性，如果使用过的脚本语言这样的写法就并不陌生（javascript、python），可简化类型转换代码，而且允许直接使用索引方式访问属性。 Simple.Data 主要常用类型有 名称 缩写 说明 DynamicStrategy DS 数据库 DynamicTable DT 数据表 SimpleQuery SQ 查询 SimpleExpression SE 条件表达式 SimpleRecord SR 记录 SimpleList SL 记录列表 ObjectReference OR 对象引用，DS.DT、DT.Field 都可转换为此对象 查询、关联、合计、函数 - Query、Join、Aggregate、Function 命令 参数 返回 说明 Select OR[] SQ 指定返回查询字段数据 Star/AllColumns null SQ 用于 Table，返回表所有字段数据 Distinct null SQ 用于 Column，过滤相同数据 As string OR 用于 Table、Column，设置列别名 Where SE SQ 更新标准 Operators 用于 Column，二元操作符+、-、*、/、%、==、!=、&lt;、&lt;=、&gt;、&gt;= In object[] OR 用于 Column，in 语法 Between int/double OR 用于 Column，两个数值之间 1.to(20) Like string OR 用于 Column，模糊条件 is null 用于 Column，查询空值 OrderBy OR SQ 升序 OrderByDescending OR SQ 降序 ThenBy OR SQ 升序，OrderBy 后面使用 ThenByDescending OR SQ 降序，OrderBy 后面使用 Natural Join 外键关联 Join DT SQ Join On Left Join DT SQ LeftJoin On With DT SQ eager-loaded，单个或多个记录 WithOne DT SQ eager-loaded，单个记录 WithMany DT SQ eager-loaded，多个记录 Having SE OR 用于 Column，Function 查询标准条件 Min null OR 用于 Column，最小值 Max null OR 用于 Column，最大值 Avg null OR 用于 Column，平均值 Sum null OR 用于 Column，合计 Count null OR 用于 Column，数量 CountDistinct null OR 用于 Column，过滤重复后的数量 Length null OR 用于 Column，字符长度 ToScalar null object 获取第一行第一列 ToScalarList null object list 获取所有行第一列 ToScalarArray null object[] 获取所有行第一列 ToScalarOrDefault null object 获取第一行第一列或默认 Implicit Casting 强类型转换，可直接赋值给予定义变量 Cast IEnumerable 强类型转换 ToList IList 获取数据对象列表 ToList IList 获取数据对象列表 ToArray dynamic[] 获取数据对象数组，遍历速度高于列表 ToArray IList 获取数据对象数组 Skip int SQ 忽略记录数量 Take int SQ 提取记录数量 WithTotalCount SQ 记录总数 First SQ 获取第一行数据 FirstOrDefault SQ 获取第一行数据或 null Single SQ 获取第一行数据 SingleOrDefault SQ 获取第一行数据或 null","categories":[{"name":"database","slug":"database","permalink":"/categories/database/"}],"tags":[{"name":"Simple.Data","slug":"Simple-Data","permalink":"/tags/Simple-Data/"}]},{"title":"Simple.Data 介绍、检索数据（1）","slug":"Simple-Data-Select","date":"2017-10-29T13:57:14.000Z","updated":"2017-10-30T13:39:49.785Z","comments":true,"path":"2017/10/29/Simple-Data-Select/","link":"","permalink":"/2017/10/29/Simple-Data-Select/","excerpt":"","text":"接触 ORM 至今为止，从最初的 NHibernate、Castle、EF 相对强大的类库，到现在使用的“很黄很暴力”的 Simple.Data，已经有10年的时间。而 ORM 之前基本都是写一句 SQL 语句查询返回 DataSet（.NET），后来在此基础上增加数据访问层 Dao 来封装，再进一步返回业务对象。现在感触最深的还是回归到可控性最强的 SQL 但无法避免返回 DataSet 问题（虽然可以用 Reader解决），而 Simple.Data 可以牺牲一定可控性的基础上换取便利的对象操作。 安装 要求 .NET 4.0 或以上 使用 nuget 搜索 simple.data.core（核心库） 根据数据库引擎需要，在主项目使用 nuget 搜索 simple.data.sqldata（mysql/oracle），安装过程同时自动安装 simple.data.adoadapter 检索数据 - retrieve data标准类型 SimpleExpression(SE)，返回 SimpleQuery(SQ) 可以通过迭代 SimpleRecord(SR) 集合获取结果数据对象，此对象为 dynamic 类型，可使用强类型转换为期望类型或 IDictionary。 dynamic 类型优点在于允许直接访问属性（列名） result.ColumnName，也可以通过索引访问 result[“ColumnName”]（记得可以的，若不行则需要强类型转换 IDictionar。 若数据存在外键，还允许在 SE 通过外键表名称直接写条件，如 table.Topic.Title.Like(“%我的心得%”)，避免繁琐的 Join On。 当然，据目前使用过程还发现一些 Bug 存在两个或以上的外键指向同一张表，SE 只建立最后一个外键（字段顺序也可能是外键顺序，但不确认），建议出现此类情况还是使用 JOIN ON 来解决 ToFirstOrDefault 导致从表仅返回第一条数据，建议使用 Find 或延迟加载从表数据 Skip 且没有 Where 引起分页条件位置不正确，导致数据分页查询返回结果不正确，建议增加默认条件 WithTotalCount 返回属性含有集合对象Bug，原因未明，建议尽量不要返回集合数据对象，改用 Select 优化，如无法避免则建议使用 dynamic 延迟加载集合对象。 Simple.Data 主要常用类型有 名称 缩写 说明 DynamicStrategy DS 数据库 DynamicTable DT 数据表 SimpleQuery SQ 查询 SimpleExpression SE 条件表达式 SimpleRecord SR 记录 SimpleList SL 记录列表 ObjectReference OR 对象引用，DS.DT、DT.Field 都可转换为此对象 命令 参数 返回 说明 All SE SQ 返回表所有数据 FindAll SE SQ 通过标准返回表数据 FindAllBy OR[] SQ 通过列名和值返回表数据 Find SE SR 通过标准返回一条表数据，若查询到多条只返回第一条 Get object[] SR 通过主键返回一条表数据 GetCount SE int 通过标准返回表数据数量 GetCountBy string int 通过列名和值返回表数据数量 Exists/Any SE bool 通过标准返回是否存在表数据 ExistsBy/AnyBy string bool 通过列名和值返回是否存在表数据数量 其他注意问题 Query、QueryBy：已过时，请使用 All、FindAllBy FindBy：已过时，请使用 FindAllBy.FirstOrDefault() 或 Get SimpleQuery：可以使用迭代或 ToList、ToFirstOrDefault、ToScalar 等 Linq 相似的方法或数据对象","categories":[{"name":"database","slug":"database","permalink":"/categories/database/"}],"tags":[{"name":"Simple.Data","slug":"Simple-Data","permalink":"/tags/Simple-Data/"}]},{"title":"HBuilder svn 插件安装","slug":"HBuilder-svn-plugin","date":"2017-10-28T14:57:54.000Z","updated":"2017-10-28T15:08:02.302Z","comments":true,"path":"2017/10/28/HBuilder-svn-plugin/","link":"","permalink":"/2017/10/28/HBuilder-svn-plugin/","excerpt":"","text":"安装步骤 工具 &gt;&gt; 插件安装 选择 SVN &gt;&gt; 安装，重启 HBuilder 工具 &gt;&gt; 插件安装 &gt;&gt; 手动安装插件（SVN 版本问题，必须更新版本） Work with： http://subclipse.tigris.org/update_1.10.x 全部保存，一直点击【下一步】，最后【完成】，重启 Hbuilder 视图 &gt;&gt; 定制透视图 命令和快捷方式选项卡勾选 SVN，tool bar 和 menu 勾选 SVN 确定后，安装完毕","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"mobile","slug":"mobile","permalink":"/tags/mobile/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"}]},{"title":"javascript 继承收集","slug":"javascript-inherit-collect","date":"2017-10-27T05:52:23.000Z","updated":"2017-10-30T12:14:01.065Z","comments":true,"path":"2017/10/27/javascript-inherit-collect/","link":"","permalink":"/2017/10/27/javascript-inherit-collect/","excerpt":"","text":"定义父类12345678910111213// 定义一个动物类function Animal (name) &#123; // 属性 this.name = name || &apos;Animal&apos;; // 实例方法 this.sleep = function()&#123; console.log(this.name + &apos; 正在睡觉！&apos;); &#125;;&#125;// 原型方法Animal.prototype.eat = function(food) &#123; console.log(this.name + &apos; 正在吃：&apos; + food);&#125;; 推荐继承直接贴代码12345678910111213141516171819202122232425262728293031323334353637383940414243// 继承function inherit(superConstructor, subConstructor) &#123; var proto = beget(superConstructor.prototype); // 核心 proto.constructor = subConstructor; // 修改构造函数 subConstructor.prototype = proto; // 修改原型链，将实例作为子类的原型&#125;;function beget(obj) &#123; var F = function () &#123;&#125;; F.prototype = obj; return new F();&#125;function Cat(name) &#123; Animal.call(this, name); // 调用父类构造函数，创建属性和实例方法 this.base = this.__proto__.__proto__; // 定义基类对象 this.color = &apos;white&apos;; // 重载实例方法，也可以使用原型方法重载 this.sleep = function(fav) &#123; if (fav) &#123; console.log(this.name + &apos; 最喜欢在&apos; + fav + &apos;睡觉&apos;); &#125; else &#123; this.base.sleep.call(this); // 注意这里是调用基类方法，使用 call 改变调用对象 &#125; &#125;&#125;inherit(Animal, Cat); // Cat 继承 Animal// 重载原型方法，必须在继承后Cat.prototype.eat = function(food, fav)&#123; if (fav) &#123; console.log(this.name + &apos; 最喜欢的食物是：&apos; + food); &#125; else &#123; this.base.eat.call(this, food); // 调用基类方法，使用 call 或 apply // this.base.eat.apply(this, arguments); &#125;&#125;var cat = new Cat(&apos;Tom cat&apos;);cat.eat(&apos;fish&apos;, true); // cat 最喜欢的食物是：fishcat.eat(&apos;fish&apos;); // cat 正在吃：fishconsole.log(typeof cat.sleep === &apos;function&apos;); // true, 实例方法无法继承 继承可使用上述代码实现，如需详细了解其他方式可见下文。 ========== 分界线 =========== 原型链继承核心： 将父类的实例作为子类的原型123456789101112function Cat()&#123; &#125;Cat.prototype = new Animal();Cat.prototype.name = &apos;cat&apos;;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.eat(&apos;fish&apos;));console.log(cat.sleep());console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); // true 问题： 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 构造继承核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）1234567891011function Cat(name)&#123; Animal.call(this); this.name = name || &apos;Tom&apos;;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 问题： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 实例继承核心：为父类实例添加新特性，作为子类实例返回123456789101112function Cat(name)&#123; var instance = new Animal(); instance.name = name || &apos;Tom&apos;; return instance;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 问题： 实例是父类的实例，不是子类的实例 不支持多继承 拷贝继承1234567891011121314function Cat(name)&#123; var animal = new Animal(); for(var p in animal)&#123; Cat.prototype[p] = animal[p]; &#125; Cat.prototype.name = name || &apos;Tom&apos;;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 问题： 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 组合继承核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用123456789101112function Cat(name)&#123; Animal.call(this); this.name = name || &apos;Tom&apos;;&#125;Cat.prototype = new Animal();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 问题： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 寄生组合继承(实现复杂)核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点123456789101112131415161718function Cat(name)&#123; Animal.call(this); this.name = name || &apos;Tom&apos;;&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true","categories":[{"name":"script","slug":"script","permalink":"/categories/script/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"collect","slug":"collect","permalink":"/tags/collect/"}]},{"title":"Grunt jshint 配置","slug":"grunt-jshint-options","date":"2017-10-27T04:45:52.000Z","updated":"2017-10-28T14:57:03.477Z","comments":true,"path":"2017/10/27/grunt-jshint-options/","link":"","permalink":"/2017/10/27/grunt-jshint-options/","excerpt":"","text":"jsHint 同 jsLint 一样都是 js 代码检查工具 jsHint 规则 参考资料http://www.cnblogs.com/code/articles/4103070.htmlhttp://www.htmlhifive.com/conts/web/view/library/JSLint_JSHint bitwise1// 禁用位运算符(如^，&amp;) curly1// if 和 while 等语句中使用&#123;&#125;来明确代码块 eqeqeq1// 使用 === 和 !== 替代 == 和 != forin1// 在 for in 循环中使用 Object.prototype.hasOwnProperty() 来过滤原型链中的属性 immed123456789// 匿名函数调用必须(function() &#123; // body &#125;());// 而不是(function() &#123; // body&#125;)();// 这是为了表明，表达式的值是函数的结果，而不是函数本身。 latedef1// 变量定义前禁止使用 newcap1// 构造函数名首字母必须大写 noarg1// 禁止使用arguments.caller和arguments.callee noempty1// 禁止出现空的代码块 nonew1// 禁止使用构造器 plusplus1// 禁止使用++和-- undef1// 禁止使用不在全局变量列表中的未定义的变量 strict1// 强制使用ES5的严格模式 freeze1234// 禁止复写原生对象(如Array, Date)的原型/* jshint freeze:true */Array.prototype.count = function (value) &#123; return 4; &#125;;// -&gt; Warning: Extending prototype of native object: &apos;Array&apos;. asi1// 允许省略分号 boss1// 允许在if，for，while语句中使用赋值;在条件语句中使用赋值经常是笔误if (a = 10) &#123;&#125; debug1// 允许debugger语句 eqnull12// 允许==null// ==null通常用来比较=== null;=== undefined evil1// 允许使用eval expr1// 允许应该出现赋值或函数调用的地方使用表达式 iterator12// 允许__iterator__;// 不是所有的浏览器都支持__iterator__。 lastsemic12// 允许单行控制块省略分号var name = (function() &#123; return &apos;Anton&apos; &#125;()); laxbreak1// 允许不安全的行中断(与laxcomma配合使用) laxcomma1// 允许逗号开头的编码样式 loopfunc1// 允许循环中定义函数 onecase1// 允许只有一个case条件的switch语句吗 proto1// 允许 proto（不是所有的浏览器都支持__proto__.） regexdash1// 在正则表达式的控制语句，连字符开头或方括号的结束 - 容忍的存在。 scripturl1// 允许 javascript:; shadow1234567891011// 允许变量shadowfunction test() &#123; var x = 10; if (true) &#123; var x = 20; &#125; return x;&#125;// 基于“函数作用域”，多次定义变量和单次定义是没有区别的，但是会造成阅读障碍。 sub12// 允许person[‘name’]// JSHint推荐使用 person.name 代替 person[‘name’] supernew1// 允许new function() &#123;…&#125;和new Object; validthis1// 允许严格模式下在非构造函数中使用this","categories":[{"name":"script","slug":"script","permalink":"/categories/script/"}],"tags":[{"name":"grunt","slug":"grunt","permalink":"/tags/grunt/"},{"name":"plugin","slug":"plugin","permalink":"/tags/plugin/"}]},{"title":"Markdown 语言学习","slug":"markdown-course","date":"2017-10-26T14:17:29.000Z","updated":"2017-10-29T14:45:57.108Z","comments":true,"path":"2017/10/26/markdown-course/","link":"","permalink":"/2017/10/26/markdown-course/","excerpt":"","text":"Markdown 的目标是实现「易读易写」。 Markdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强。 标题123456H1 :# Header 1H2 :## Header 2H3 :### Header 3H4 :#### Header 4H5 :##### Header 5H6 :###### Header 6 H1 :# Header 1H2 :## Header 2H3 :### Header 3H4 :#### Header 4H5 :##### Header 5H6 :###### Header 6 文本样式123456789101112（带“*”星号的文本样式，在原版 Markdown 标准中不存在，但在其大部分衍生标准中被添加）链接 :[Title](URL)加粗 :**Bold**斜体字 :*Italics**删除线 :~~text~~*高亮 :==text==段落 : 段落之间空一行换行符 : 一行结束时输入两个空格列表 :* 添加星号成为一个新的列表项。引用 :&gt; 引用内容内嵌代码 : `alert(&apos;Hello World&apos;);`画水平线 (HR) :-------- 链接 :Title加粗 :Bold斜体字 :Italics删除线 :text 高亮 :==text==段落 : 段落之间空一行换行符 : 一行结束时输入两个空格列表 :* 添加星号成为一个新的列表项。引用 :&gt; 引用内容内嵌代码 : alert(&#39;Hello World&#39;);画水平线 (HR) :——– 图片1![Title](src). 写代码1连续3个【`】闭合，闭合部分写入代码 HTML 代码在 HTML 区块标签间的 Markdown 格式语法将不会被处理。处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换 符号 输入 &amp; &amp;amp; &gt; &amp;gt; &lt; &amp;lt; 区块引用 Blockquotes12345678&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt;&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing.&gt;&gt; Back to the first level. This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. Back to the first level. 列表12345无序列表使用星号、加号或是减号作为列表标记* Red // eq: + Red - Red* Green Light* Blue Red GreenLight Blue 123456有序列表则使用数字接着一个英文句点很重要的一点是，列表标记上使用的数字并不会影响输出的 HTML 结果为未来考虑，建议保留顺序1. Bird2. McHale3. Parish Bird McHale Parish 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;p&gt; 标签包起来123* Bird* Magic 当然，项目列表很可能会不小心产生，像是下面这样的写法：11986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。11986\\. What a great season. 表格12345| Tables | Col | Type || ------------- |:-------------:| -----:|| SA_User | Type | int || SA_Role | RoleName | char || SA_UserRole | UserId | 1 | Tables Col Type SA_User Type int SA_Role RoleName char SA_UserRole UserId 1 自动链接12一般网址的链接文字就和链接地址一样&lt;http://example.com/&gt; 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），可以在星号的前面加上反斜杠：1\\*literal asterisks\\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号","categories":[{"name":"script","slug":"script","permalink":"/categories/script/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"md","slug":"md","permalink":"/tags/md/"}]},{"title":"YMAL 语言学习","slug":"yaml-course","date":"2017-10-26T14:17:21.000Z","updated":"2017-10-26T15:58:05.995Z","comments":true,"path":"2017/10/26/yaml-course/","link":"","permalink":"/2017/10/26/yaml-course/","excerpt":"","text":"参考：阮一峰的网络日志 - YAML 语言教程 YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便，也类似于标准通用标记语言的子集XML的数据描述语言，语法比XML简单很多。 YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。 基本语法 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可1# 表示注释，从这个字符一直到行尾，都会被解析器忽略。 数据结构 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 比对 YAML 和 JavascriptYAML 转换 Javascript 对象的一组键值对，使用冒号结构表示。 12345animal: petsout~ &#123; animal: &apos;pets&apos; &#125;# 行内对象hash: &#123; name: Steve, foo: bar &#125;out~ &#123; hash: &#123; name: &apos;Steve&apos;, foo: &apos;bar&apos; &#125; &#125; 一组连词线开头的行，构成一个数组。 12345678910111213- Cat- Dog- Goldfishout~ [ &apos;Cat&apos;, &apos;Dog&apos;, &apos;Goldfish&apos; ]# 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。- - Cat - Dog - Goldfishout~ [ [ &apos;Cat&apos;, &apos;Dog&apos;, &apos;Goldfish&apos; ] ]# 行内表示法animal: [Cat, Dog]out~ &#123; animal: [ &apos;Cat&apos;, &apos;Dog&apos; ] &#125; 对象和数组可以结合使用，形成复合结构 123456789languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 123456&#123; languages: [ &apos;Ruby&apos;, &apos;Perl&apos;, &apos;Python&apos; ], websites: &#123; YAML: &apos;yaml.org&apos;, Ruby: &apos;ruby-lang.org&apos;, Python: &apos;python.org&apos;, Perl: &apos;use.perl.org&apos; &#125; &#125; 纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。 字符串 - 字符串默认不使用引号表示。 布尔值 - 布尔值用true和false表示 整数 - 数值直接以字面量的形式表示 浮点数 Null - # null用~表示 时间 - 时间采用 ISO8601 格式 日期 - 日期采用复合 iso8601 格式的年、月、日表示。 使用两个感叹号，强制转换数据类型 12e: !!str 123f: !!str true 字符串字符串是最常见，也是最复杂的一种数据类型。 123# 字符串默认不使用引号表示。str: 这是一行字符串out~ &#123; str: &apos;这是一行字符串&apos; &#125; 123# 如果字符串之中包含空格或特殊字符，需要放在引号之中。str: &apos;内容： 字符串&apos;out~ &#123; str: &apos;内容: 字符串&apos; &#125; 1234# 单引号和双引号都可以使用，双引号不会对特殊字符转义。s1: &apos;内容\\n字符串&apos;s2: &quot;内容\\n字符串&quot;out~ &#123; s1: &apos;内容\\\\n字符串&apos;, s2: &apos;内容\\n字符串&apos; &#125; 123# 单引号之中如果还有单引号，必须连续使用两个单引号转义。str: &apos;labor&apos;&apos;s day&apos;out~ &#123; str: &apos;labor\\&apos;s day&apos; &#125; 12345# 字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。str: 这是一段 多行 字符串out~ &#123; str: &apos;这是一段 多行 字符串&apos; &#125; 12345678# 多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行。this: | Foo Barthat: &gt; Foo Barout~ &#123; this: &apos;Foo\\nBar\\n&apos;, that: &apos;Foo Bar\\n&apos; &#125; 1234567891011# +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。s1: | Foos2: |+ Foos3: |- Fooout~ &#123; s1: &apos;Foo\\n&apos;, s2: &apos;Foo\\n\\n\\n&apos;, s3: &apos;Foo&apos; &#125; 1234567# 字符串之中可以插入 HTML 标记。message: | &lt;p style=&quot;color: red&quot;&gt; 段落 &lt;/p&gt;out~ &#123; message: &apos;\\n&lt;p style=&quot;color: red&quot;&gt;\\n 段落\\n&lt;/p&gt;\\n&apos; &#125; 引用锚点&amp;和别名*，可以用来引用 1234567891011defaults: &amp;defaults adapter: postgres host: localhostdevelopment: database: myapp_development &lt;&lt;: *defaultstest: database: myapp_test &lt;&lt;: *defaults &amp;用来建立锚点（defaults），&lt;&lt;表示合并到当前数据，*用来引用锚点。等同于 12345678910111213defaults: adapter: postgres host: localhostdevelopment: database: myapp_development adapter: postgres host: localhosttest: database: myapp_test adapter: postgres host: localhost 另一种写法： 12345- &amp;showell Steve - Clark - Brian - Oren - *showell 等同于 1[ &apos;Steve&apos;, &apos;Clark&apos;, &apos;Brian&apos;, &apos;Oren&apos;, &apos;Steve&apos; ]","categories":[{"name":"script","slug":"script","permalink":"/categories/script/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"ymal","slug":"ymal","permalink":"/tags/ymal/"}]},{"title":"hexo themes (2)","slug":"hexo-themes-2","date":"2017-10-25T15:03:48.000Z","updated":"2017-10-25T15:30:54.704Z","comments":true,"path":"2017/10/25/hexo-themes-2/","link":"","permalink":"/2017/10/25/hexo-themes-2/","excerpt":"","text":"安装模板遇到的问题网络安装模块因网络原因导致失败，也有可能是资源已经关闭（可能性不高） themes/.config.yml每个模板都会有自己的配置，与博客自己的 _config.yml 不一样，此配置文件只对模板起作用，因不了解，导致 less 生成 css 文件失败 .config.yml1languages: zh-CN # 使用不存在的语言 zh，导致内部调用 ca themes/languages因配置错误语言，发现 ejs 具体调用语言方法，具体待进一步去学习1__(&apos;index.category&apos;) # 估计是读取 languages yml 配置的 index.category 变量值 node_modules模块脚本等资源都可以直接修改，因发现 hexo-asset-image 模块生产图片路径有误，直接修改 index.js 文件处理脚本部分问题后，可正确输出图片 多级 categories在 md 文件的 categories 写入数组，将按照数组顺序建立层级关系1234categories: # parent &gt;&gt; child &gt;&gt; tail - parent - child - tail","categories":[{"name":"system","slug":"system","permalink":"/categories/system/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"theme","slug":"theme","permalink":"/tags/theme/"}]},{"title":"一张图简述 MIT 等协议","slug":"about-license-for-simple","date":"2017-10-25T14:08:27.000Z","updated":"2017-10-25T15:28:25.013Z","comments":true,"path":"2017/10/25/about-license-for-simple/","link":"","permalink":"/2017/10/25/about-license-for-simple/","excerpt":"","text":"License世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种—-GPL、BSD、MIT、Mozilla、Apache和LGPL—-之中做选择，也很复杂，这张图比那种一堆文字要简单易懂的多 引用：如何选择开源许可证？","categories":[{"name":"collect","slug":"collect","permalink":"/categories/collect/"}],"tags":[{"name":"license","slug":"license","permalink":"/tags/license/"}]},{"title":"hexo theme","slug":"hexo-themes","date":"2017-10-25T03:53:52.000Z","updated":"2017-10-25T15:34:09.146Z","comments":true,"path":"2017/10/25/hexo-themes/","link":"","permalink":"/2017/10/25/hexo-themes/","excerpt":"","text":"官网提供的模板模板地址 hexo themes，点击图片可以预览效果，点击文字可以进入 git下面列举示例，引用 hexo-theme-bootstrap-blog 安装主题必须在 hexo 2.4 或以上 将主题拉到本地: 1$ git clone https://github.com/cgmartin/hexo-theme-bootstrap-blog.git themes/bootstrap-blog 安装 hexo-tag-bootstrap for more Bootstrap tags (textcolors, buttons, labels, badges, etc.): 1$ npm install hexo-tag-bootstrap --save 安装 hexo-tag-fontawesome for placing Font Awesome icons in your Markdown: 1$ npm install hexo-tag-fontawesome --save 修改脚本引用因 google 国内无法访问，打开 themes/bootstrap-blog/layout/_partial/inline-scripts.ejs，将 jQuery 和 bootstrap 引用修改： 123&lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 配置 _config.yml 的 theme 配置 1234theme: hexo-theme-xups# 更新 git$ cd themes/bootstrap-blog$ git pull","categories":[{"name":"system","slug":"system","permalink":"/categories/system/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"theme","slug":"theme","permalink":"/tags/theme/"}]},{"title":"hexo 安装","slug":"hexo-install","date":"2017-10-25T03:05:14.000Z","updated":"2017-10-25T15:33:11.854Z","comments":true,"path":"2017/10/25/hexo-install/","link":"","permalink":"/2017/10/25/hexo-install/","excerpt":"","text":"hexo 环境node.js &amp; npm到官网下载最新安装包 node.js，已经包括 node.js 和 npm，默认安装便可 git到官网下载最新安装包 git，安装后一定要重启，否则 git 无法作为全局命令使用（弄了N次环境变量都不行，结果重启一下就好了，晕死） hexo 直接给命令12345$ npm install hexo-cli -g # 作为全局命令安装 hexo $ hexo init blog # 通过 cd 命令选定目录后初始化建立 blog$ cd blog # 进入 blog 目录$ npm install # 还原 npm 引用$ hexo server # 启动 hexo 服务，默认4000端口 发布 git 静态页面 配置github账户信息 12$ git config --global user.name &quot;YourName&quot; $ git config --global user.email &quot;YourEmail&quot; SSH进入 blog 所在目录，右键打开“Git Bash Here” 1234$ ssh-keygen -t rsa -C &quot;youremail&quot; # 第一个提示信息是 .ssh 目录，直接回车 # 第二、三个提示是输入密匙，两次一致便可$ cd ~/.ssh # 进入 SSH 目录$ cat id_rsa.pub # SSH 密匙，复制并在 git 上面添加（注意不要复制最后的邮件地址） git 配置在参考 hexo从零开始到搭建完整 及个人博客 首个博客","categories":[{"name":"system","slug":"system","permalink":"/categories/system/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"install","slug":"install","permalink":"/tags/install/"}]},{"title":"首个博客","slug":"first-blog","date":"2017-10-24T15:11:14.000Z","updated":"2017-10-25T13:57:12.893Z","comments":true,"path":"2017/10/24/first-blog/","link":"","permalink":"/2017/10/24/first-blog/","excerpt":"","text":"首次发布个人博客尝试学习 node.js 搭建服务端，学习 hexo + node.js 开源项目创建个人博客，初步了解该项目使用技术有 技术 介绍 node.js 一个Javascript运行环境(runtime)；Node.js 使用事件驱动，非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 git 分布式版本控制系统 YAML _config.yml另一种标记语言，它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。 ejs EJS是一个JavaScript模板库，用来从JSON数据中生成HTML字符串。 md Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 终于成功搭建 hexo坑坑坑….. 稍微总结一下 hexo 搭建遇到的问题 搭建了两个网站，结果配置 _config.yml 的 deploy 搞混了 顺带说明一下变量和值之间的冒号“:”必须在冒号后添加一个空格，语法要求 创建 SSH 命令注意要大小写匹配安装 1$ ssh-keygen -t rsa -C &quot;youremail&quot; # 配置 ssh 安装 hexo-deployer-git 若失败或提示忽略这忽略那，建议删除 node_modules 目录，重新执行 npm install 12$ npm install hexo-deployer-git --save$ npm install 下一步掌握 _config.yml 配置文件及安装 themes","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"/tags/blog/"}]}]}