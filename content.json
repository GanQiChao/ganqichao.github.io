{"meta":{"title":"GanQiChao's Blog","subtitle":"Tec","description":null,"author":"GanQiChao","url":""},"pages":[],"posts":[{"title":"git 学习 3","slug":"git-study-3","date":"2017-11-05T15:04:15.000Z","updated":"2017-11-05T15:28:22.426Z","comments":true,"path":"2017/11/05/git-study-3/","link":"","permalink":"/2017/11/05/git-study-3/","excerpt":"","text":"远程仓库 添加远程库GitHub 注册账号并建立 repository，Clone with SSH1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; // 一路回车，使用默认值即可 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。登陆GitHub，打开“Account settings”，“SSH Keys”页面然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 首次注意事项：12345git pull origin master// 若上述命令失败，请使用一下命令git pull origin master --allow-unrelated-histories // 第一次踩雷// 可正式推送文件到远程仓库了~~！！git push -u origin master git vim 保存退出：按下 “ESC” 键，退出编辑模式，切换到命令模式，在命令模式下键入”ZZ”或者”:wq”保存修改并且退出 vi commit 若不带参数 -m 也会进入 vim 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步 从远程库克隆远程库已经准备好，用命令 git clone 克隆一个本地库$ git clone git@github.com:[ account name ]/[ repository name ]","categories":[],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"Git 学习 2","slug":"git-study-2","date":"2017-11-05T13:21:11.000Z","updated":"2017-11-05T14:32:02.461Z","comments":true,"path":"2017/11/05/git-study-2/","link":"","permalink":"/2017/11/05/git-study-2/","excerpt":"","text":"本地版本库 - repository**什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 命令12345678910111213141516171819// 在目录右键选择 git bash$ git init // 初始化 git 仓库$ git add &quot;readme.txt&quot; // 添加文件到 git 仓库//$ git add &quot;r1.txt&quot; &quot;r2.txt&quot; // 添加多个文件到 git 仓库$ git commit -m &quot;wrote a readme file&quot; // 提交到仓库$ git status // 查看工作区状态$ git diff // 查看修改内容$ git add &quot;readme.txt&quot;$ git status$ git commit -m &quot;add distributed&quot;$ git add &quot;readme.txt&quot;$ git commit -m &quot;append GPL&quot;$ git log // 查看提交日记$ git log --pretty=oneline // 查看提交日记，简化信息$ git reset --hard HEAD^ // 退回一个版本，^^两个版本，~100一百个版本$ git reset --hard [commit_id] // 恢复某一提交版本$ git reflog // 查看命令历史$ git diff HEAD -- readme.txt // 查看工作区和版本库里面最新版本的区别 工作区和暂缓区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 工作区 - Working Directory电脑能看到的目录 版本库 - Repository工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。Git 的版本库里存了很多东西，其中最重要的就是称为 stage（或者叫 index）的暂存区，还有 Git 为我们自动创建的第一个分支 master，以及指向 master 的一个指针叫 HEAD。 add 命令实际是将要提交的所有修改放到暂存区（Stage），然后使用 commit 一次性把暂存区的所有修改提交到分区。 管理修改如果不 add 到暂存区，那就不会加入到 commit 中。第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit（因第二次修改没有放入暂存区，所以第二次的修改不会被提交）第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 撤销修改12$ git checkout -- readme.txt // 撤销修改$ git reset HEAD readme.txt // 提交到暂存区使用 reset 命令，然后 checkout 删除文件若 commit 删除需要还原，请使用 git reset 命令123$ git rm test.txt// 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。$ git checkout -- test.txt","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"Git 学习","slug":"git-study","date":"2017-11-05T09:19:15.000Z","updated":"2017-11-05T13:33:01.140Z","comments":true,"path":"2017/11/05/git-study/","link":"","permalink":"/2017/11/05/git-study/","excerpt":"","text":"推荐廖雪峰的官方网 Git教程 Git 的由来不多说，只有一句 Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 集中式先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 分布式那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 现状 CVS/SVNCVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。 收费除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。 VSS微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。 Git分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"markdown 语言学习 2","slug":"markdown-course-2","date":"2017-11-02T14:39:31.000Z","updated":"2017-11-02T15:03:50.882Z","comments":true,"path":"2017/11/02/markdown-course-2/","link":"","permalink":"/2017/11/02/markdown-course-2/","excerpt":"","text":"本章主要介绍前端 MarkDown 解释脚本 showdown 的使用和坑。 git 地址 showdown.js cdn 地址 cdn showdown 1.7.6 源码 cdn showdown 1.7.6 压缩 直接上代码123456789101112function compile()&#123; // 获取要转换的文字 var text = document.getElementById(&quot;markdown&quot;).value; // 创建实例 var converter = new showdown.Converter(); // 支持表格转换 converter.setOption(&apos;tables&apos;, true); // 进行转换 var html = converter.makeHtml(text); // 展示到对应的地方 result便是id名称 document.getElementById(&quot;html-shower&quot;).innerHTML = html;&#125; git wiki 链接 Showdown Showdown Options 表格支持的大坑 一定要用两个 “–”，保证不要有空行，其他格式都不重要，为兼容考虑建议习惯“–”就好 1234| table | column | type || -- | -- | -- || User | UserName | string || Role | RoleName | string | 效果| table | column | type || – | – | – || User | UserName | string || Role | RoleName | string |","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"script","slug":"script","permalink":"/tags/script/"},{"name":"md","slug":"md","permalink":"/tags/md/"}]},{"title":"Simple.Data 关于视图使用","slug":"Simple-Data-about-view-use","date":"2017-11-02T03:51:21.000Z","updated":"2017-11-02T14:15:16.833Z","comments":true,"path":"2017/11/02/Simple-Data-about-view-use/","link":"","permalink":"/2017/11/02/Simple-Data-about-view-use/","excerpt":"","text":"Simple.Data 分页必须依赖数据表的主键，否则抛异常 AdoAdapterException 【Cannot apply paging to table with no primary key.】 基于数据查询性能考虑，我们会建立视图简化查询语句，也就是创建 view 对象，但视图是无法拥有主键，所以提出以下方案。 参考原有分页方法，为表建立排序字段 【#】123ROW_NUMBER() OVER(&#123;0&#125;) AS [_#_] // &#123;0&#125; 字段名称 + 排序// CreateTime 降序ROW_NUMBER() OVER(CreateTime desc) AS [_#_] 因此视图的建立应该指派其排序方式，分页编码使用如下：12var pageRange = (offset + 1).to(offset + limit);expression = expression.And(limit &gt; 0, () =&gt; view[&quot;_#_&quot;] == pageRange); 但此方法不可添加查询条件，否则排序结果因筛选数据而导致失效 特殊情况between and 排序功能失效，原因未能确认暂时只能使用 Linq 重新排序，要么修改 Simple.Data 分页处理，在条件后增加 order by","categories":[{"name":"database","slug":"database","permalink":"/categories/database/"}],"tags":[{"name":"Simple.Data","slug":"Simple-Data","permalink":"/tags/Simple-Data/"}]},{"title":"Simple.Data 使用建议","slug":"Simple-Data-suggest-for-use","date":"2017-10-31T12:43:42.000Z","updated":"2017-10-31T15:02:44.802Z","comments":true,"path":"2017/10/31/Simple-Data-suggest-for-use/","link":"","permalink":"/2017/10/31/Simple-Data-suggest-for-use/","excerpt":"","text":"实际使用 Simple.Data 依然存在一些问题需要注意，还有一些使用经验分析Simple.Data 使用动态类型可以忽略大小写，但建议采用 C# 规范保持首字母大写 加载关联对象数据库存在表 Node，字段有 No 和 ParentNo，No 是主键，ParentNo 是外键关联表 Node 的 No，即自身引用 定义节点 定义数据类和对象类 12345678910111213// 节点数据表类public class Node&#123; public string No &#123; get; set; &#125; // 当前节点编号 public string ParentNo &#123; get; set; &#125; // 上级节点编号&#125;// 节点对象类public class NodeObject&#123; public string No &#123; get; set; &#125; // 当前节点编号 public NodeObject Parent &#123; get; set; &#125; // 上级节点对象&#125; 检索节点 变量 db 表示数据库对象实体 1234var no = &quot;001&quot;;var getToDynamic = db.Node.Get(no); // dynamicvar getByTemplate = db.Node.Get&lt;Node&gt;(no); // dynamic，实际类型 NodeNode getToNode = db.Node.Get&lt;Node&gt;(no); // Node dynamic 类型转换 1234var nodeByStrong = (Node)getToDynamic; // 强类型转换 NodeNode nodeByDefined = getToDynamic; // 定义转换实体 Nodestring parentNo = getToDynamic.ParentNo; // dynamic 获取属性//string parentNo = nodeByStrong.ParentNo; // 实际类型获取属性 读取上级节点 12345678910111213/* 存在外键可通过表名获取 SimpleQuery，再获取数据对象 * 原理是 SimpleRecord 分析外键获取 SimpleQuery * SimpleQuery 对象使用部分命令，如：OrderBy/Select 等 * 但因存在 Where 命令，暂时为止如何使用重写 Where */var parentByDynamic = getToDynamic.Node.FirstOrDefault();var gradeParent = getToDynamic.Node.Node.FirstOrDefault(); // 待测试/* 通过上级节点对象获取编号 * 通过属性获取上级节点编号 */Assert.AreEqual(parentByDynamic.No, getToDynamic.ParentNo); // trueAssert.AreEqual(gradeParent.No, parentByDynamic.ParentNo); // true 节点对象使用 12345678910111213141516// NodeObject，可以使用 var 定义，注意不可 Get&lt;NodeObject&gt;，否则 Node 没有值dynamic nodeObject1 = db.Node.With(db.Node).Get(no);// 相当于：dynamic nodeObject1 = db.Node.WithNode().Get(no);// NodeObject，可以使用 var 或 dynamic 定义，若不使用 As 则无法赋值 ParentNodeObject nodeObject2 = db.Node.With(db.Node.As(&quot;Parent&quot;)).Get(no);/* 相当于 * dynamic node = db.Node; // 用一张表情况下建议使用变量，代码更容易理解 * NodeObject nodeObject1 = db.Node * Join(db.Node.As(&quot;Parent&quot;), out parent).On(parent.No == node.ParentNo) * //.Join(db.Node.As(&quot;Parent&quot;), out parent).On(no: node.ParentNo) * .With(parent.As(&quot;Parent&quot;)) * .Get(no); */Assert.AreEqual(nodeObject1.Node.No, nodeObject2.Parent.No)","categories":[{"name":"database","slug":"database","permalink":"/categories/database/"}],"tags":[{"name":"Simple.Data","slug":"Simple-Data","permalink":"/tags/Simple-Data/"}]},{"title":"sql 日期时间函数","slug":"sql-date-function","date":"2017-10-30T13:40:40.000Z","updated":"2017-10-30T13:55:47.082Z","comments":true,"path":"2017/10/30/sql-date-function/","link":"","permalink":"/2017/10/30/sql-date-function/","excerpt":"","text":"datediff功能： 返回两个日期之间的间隔语法： datediff ( date-path, date-expression-1, date-expression-2 )date-part： year | quarter | month | week | day | hour | minute | second | milliseconddate-part 2： yy/yyyy | qq/q | mm/m | wk/ww | dd,d | hh | mi/n | ss/s | ms | dy/y(年的某一日) getdate功能： 返回当前系统日期时间语法： getdate() day、month、year功能： 返回天、月、年 dateadd功能： 返回增加日期类型后的日期语法：dateadd ( date-part, number, date ) datepart功能：返回指定日期类型的值，等同于 day()、month()、year()语法：datapart ( date-part, date)","categories":[{"name":"database","slug":"database","permalink":"/categories/database/"}],"tags":[{"name":"collect","slug":"collect","permalink":"/tags/collect/"},{"name":"sql","slug":"sql","permalink":"/tags/sql/"}]},{"title":"Simple.Data 检索数据（2）","slug":"Simple-Data-Select-2","date":"2017-10-30T12:15:19.000Z","updated":"2017-11-05T09:07:14.822Z","comments":true,"path":"2017/10/30/Simple-Data-Select-2/","link":"","permalink":"/2017/10/30/Simple-Data-Select-2/","excerpt":"","text":"Simple.Data 利用 .NET 4.0 动态类型技术 dynamic，令此对象支持想要的任何特性，如果使用过的脚本语言这样的写法就并不陌生（javascript、python），可简化类型转换代码，而且允许直接使用索引方式访问属性。 Simple.Data 主要常用类型有 名称 缩写 说明 DynamicStrategy DS 数据库 DynamicTable DT 数据表 SimpleQuery SQ 查询 SimpleExpression SE 条件表达式 SimpleRecord SR 记录 SimpleList SL 记录列表 ObjectReference OR 对象引用，DS.DT、DT.Field 都可转换为此对象 查询、关联、合计、函数 - Query、Join、Aggregate、Function 命令 参数 返回 说明 Select OR[] SQ 指定返回查询字段数据 Star/AllColumns null SQ 用于 Table，返回表所有字段数据 Distinct null SQ 用于 Column，过滤相同数据 As str OR 用于 Table、Column，设置列别名 Where SE SQ 更新标准 Operators 用于 Column，二元操作符+、-、*、/、%、==、!=、&lt;、&lt;=、&gt;、&gt;= In obj[] OR 用于 Column，in 语法 Between num OR 用于 Column，两个数值之间 1.to(20)，也支持日期 Like str OR 用于 Column，模糊条件 is null 用于 Column，查询空值 OrderBy OR SQ 升序 OrderByDescending OR SQ 降序 ThenBy OR SQ 升序，OrderBy 后面使用 ThenByDescending OR SQ 降序，OrderBy 后面使用 Natural Join 外键关联 Join DT SQ Join On Left Join DT SQ LeftJoin On With DT SQ eager-loaded，单个或多个记录 WithOne DT SQ eager-loaded，单个记录 WithMany DT SQ eager-loaded，多个记录 Having SE OR 用于 Column，Function 查询标准条件 Min null OR 用于 Column，最小值 Max null OR 用于 Column，最大值 Avg null OR 用于 Column，平均值 Sum null OR 用于 Column，合计 Count null OR 用于 Column，数量 CountDistinct null OR 用于 Column，过滤重复后的数量 Length null OR 用于 Column，字符长度 ToScalar null object 获取第一行第一列 ToScalarList null IList&lt;&gt; 获取所有行第一列 ToScalarArray null object[] 获取所有行第一列 ToScalarOrDefault null object 获取第一行第一列或默认 Implicit Casting 强类型转换，可直接赋值给予定义变量 Cast IEnumerable 强类型转换 ToList IList 获取数据对象列表 ToList IList 获取数据对象列表 ToArray dynamic[] 获取数据对象数组，遍历速度高于列表 ToArray IList 获取数据对象数组 Skip int SQ 忽略记录数量 Take int SQ 提取记录数量 WithTotalCount SQ 记录总数 First SQ 获取第一行数据 FirstOrDefault SQ 获取第一行数据或 null Single SQ 获取第一行数据 SingleOrDefault SQ 获取第一行数据或 null","categories":[{"name":"database","slug":"database","permalink":"/categories/database/"}],"tags":[{"name":"Simple.Data","slug":"Simple-Data","permalink":"/tags/Simple-Data/"}]},{"title":"Simple.Data 介绍、检索数据（1）","slug":"Simple-Data-Select","date":"2017-10-29T13:57:14.000Z","updated":"2017-11-02T15:11:04.891Z","comments":true,"path":"2017/10/29/Simple-Data-Select/","link":"","permalink":"/2017/10/29/Simple-Data-Select/","excerpt":"","text":"接触 ORM 至今为止，从最初的 NHibernate、Castle、EF 相对强大的类库，到现在使用的“很黄很暴力”的 Simple.Data，已经有10年的时间。而 ORM 之前基本都是写一句 SQL 语句查询返回 DataSet（.NET），后来在此基础上增加数据访问层 Dao 来封装，再进一步返回业务对象。现在感触最深的还是回归到可控性最强的 SQL 但无法避免返回 DataSet 问题（虽然可以用 Reader解决），而 Simple.Data 可以牺牲一定可控性的基础上换取便利的对象操作。 安装 要求 .NET 4.0 或以上 使用 nuget 搜索 simple.data.core（核心库） 根据数据库引擎需要，在主项目使用 nuget 搜索 simple.data.sqldata（mysql/oracle），安装过程同时自动安装 simple.data.adoadapter 检索数据 - retrieve data标准类型 SimpleExpression(SE)，返回 SimpleQuery(SQ) 可以通过迭代 SimpleRecord(SR) 集合获取结果数据对象，此对象为 dynamic 类型，可使用强类型转换为期望类型或 IDictionary。 dynamic 类型优点在于允许直接访问属性（列名） result.ColumnName，也可以通过索引访问 result[“ColumnName”]（记得可以的，若不行则需要强类型转换 IDictionar。 若数据存在外键，还允许在 SE 通过外键表名称直接写条件，如 table.Topic.Title.Like(“%我的心得%”)，避免繁琐的 Join On。 当然，据目前使用过程还发现一些 Bug 存在两个或以上的外键指向同一张表，SE 只建立最后一个外键（字段顺序也可能是外键顺序，但不确认），建议出现此类情况还是使用 JOIN ON 来解决 ToFirstOrDefault 导致从表仅返回第一条数据，建议使用 Find 或延迟加载从表数据 Skip 且没有 Where 引起分页条件位置不正确，导致数据分页查询返回结果不正确，建议增加默认条件 WithTotalCount 返回属性含有集合对象Bug，原因未明，建议尽量不要返回集合数据对象，改用 Select 优化，如无法避免则建议使用 dynamic 延迟加载集合对象。 Simple.Data 主要常用类型有 名称 缩写 说明 DynamicStrategy DS 数据库 DynamicTable DT 数据表 SimpleQuery SQ 查询 SimpleExpression SE 条件表达式 SimpleRecord SR 记录 SimpleList SL 记录列表 ObjectReference OR 对象引用，DS.DT、DT.Field 都可转换为此对象 命令 参数 返回 说明 All SE SQ 返回表所有数据 FindAll SE SQ 通过标准返回表数据 FindAllBy OR[] SQ 通过列名和值返回表数据 Find SE SR 通过标准返回一条表数据，若查询到多条只返回第一条 Get o[] SR 通过主键返回一条表数据 GetCount SE int 通过标准返回表数据数量 GetCountBy str int 通过列名和值返回表数据数量 Exists/Any SE bool 通过标准返回是否存在表数据 ExistsBy/AnyBy str bool 通过列名和值返回是否存在表数据数量 其他注意问题 Query、QueryBy：已过时，请使用 All、FindAllBy FindBy：已过时，请使用 FindAllBy.FirstOrDefault() 或 Get SimpleQuery：可以使用迭代或 ToList、ToFirstOrDefault、ToScalar 等 Linq 相似的方法或数据对象","categories":[{"name":"database","slug":"database","permalink":"/categories/database/"}],"tags":[{"name":"Simple.Data","slug":"Simple-Data","permalink":"/tags/Simple-Data/"}]},{"title":"HBuilder svn 插件安装","slug":"HBuilder-svn-plugin","date":"2017-10-28T14:57:54.000Z","updated":"2017-11-02T14:41:27.994Z","comments":true,"path":"2017/10/28/HBuilder-svn-plugin/","link":"","permalink":"/2017/10/28/HBuilder-svn-plugin/","excerpt":"","text":"安装步骤 工具 &gt;&gt; 插件安装 选择 SVN &gt;&gt; 安装，重启 HBuilder 工具 &gt;&gt; 插件安装 &gt;&gt; 手动安装插件（SVN 版本问题，必须更新版本） Work with： http://subclipse.tigris.org/update_1.10.x 全部保存，一直点击【下一步】，最后【完成】，重启 Hbuilder 视图 &gt;&gt; 定制透视图 命令和快捷方式选项卡勾选 SVN，tool bar 和 menu 勾选 SVN 确定后，安装完毕","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"mobile","slug":"mobile","permalink":"/tags/mobile/"},{"name":"plugin","slug":"plugin","permalink":"/tags/plugin/"}]},{"title":"javascript 继承收集","slug":"javascript-inherit-collect","date":"2017-10-27T05:52:23.000Z","updated":"2017-11-02T14:45:39.950Z","comments":true,"path":"2017/10/27/javascript-inherit-collect/","link":"","permalink":"/2017/10/27/javascript-inherit-collect/","excerpt":"","text":"定义父类12345678910111213// 定义一个动物类function Animal (name) &#123; // 属性 this.name = name || &apos;Animal&apos;; // 实例方法 this.sleep = function()&#123; console.log(this.name + &apos; 正在睡觉！&apos;); &#125;;&#125;// 原型方法Animal.prototype.eat = function(food) &#123; console.log(this.name + &apos; 正在吃：&apos; + food);&#125;; 推荐继承直接贴代码12345678910111213141516171819202122232425262728293031323334353637383940414243// 继承function inherit(superConstructor, subConstructor) &#123; var proto = beget(superConstructor.prototype); // 核心 proto.constructor = subConstructor; // 修改构造函数 subConstructor.prototype = proto; // 修改原型链，将实例作为子类的原型&#125;;function beget(obj) &#123; var F = function () &#123;&#125;; F.prototype = obj; return new F();&#125;function Cat(name) &#123; Animal.call(this, name); // 调用父类构造函数，创建属性和实例方法 this.base = this.__proto__.__proto__; // 定义基类对象 this.color = &apos;white&apos;; // 重载实例方法，也可以使用原型方法重载 this.sleep = function(fav) &#123; if (fav) &#123; console.log(this.name + &apos; 最喜欢在&apos; + fav + &apos;睡觉&apos;); &#125; else &#123; this.base.sleep.call(this); // 注意这里是调用基类方法，使用 call 改变调用对象 &#125; &#125;&#125;inherit(Animal, Cat); // Cat 继承 Animal// 重载原型方法，必须在继承后Cat.prototype.eat = function(food, fav)&#123; if (fav) &#123; console.log(this.name + &apos; 最喜欢的食物是：&apos; + food); &#125; else &#123; this.base.eat.call(this, food); // 调用基类方法，使用 call 或 apply // this.base.eat.apply(this, arguments); &#125;&#125;var cat = new Cat(&apos;Tom cat&apos;);cat.eat(&apos;fish&apos;, true); // cat 最喜欢的食物是：fishcat.eat(&apos;fish&apos;); // cat 正在吃：fishconsole.log(typeof cat.sleep === &apos;function&apos;); // true, 实例方法无法继承 继承可使用上述代码实现，如需详细了解其他方式可见下文。 ========== 分界线 =========== 原型链继承核心： 将父类的实例作为子类的原型123456789101112function Cat()&#123; &#125;Cat.prototype = new Animal();Cat.prototype.name = &apos;cat&apos;;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.eat(&apos;fish&apos;));console.log(cat.sleep());console.log(cat instanceof Animal); // true console.log(cat instanceof Cat); // true 问题： 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 构造继承核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）1234567891011function Cat(name)&#123; Animal.call(this); this.name = name || &apos;Tom&apos;;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 问题： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 实例继承核心：为父类实例添加新特性，作为子类实例返回123456789101112function Cat(name)&#123; var instance = new Animal(); instance.name = name || &apos;Tom&apos;; return instance;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 问题： 实例是父类的实例，不是子类的实例 不支持多继承 拷贝继承1234567891011121314function Cat(name)&#123; var animal = new Animal(); for(var p in animal)&#123; Cat.prototype[p] = animal[p]; &#125; Cat.prototype.name = name || &apos;Tom&apos;;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 问题： 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 组合继承核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用123456789101112function Cat(name)&#123; Animal.call(this); this.name = name || &apos;Tom&apos;;&#125;Cat.prototype = new Animal();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 问题： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 寄生组合继承(实现复杂)核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点123456789101112131415161718function Cat(name)&#123; Animal.call(this); this.name = name || &apos;Tom&apos;;&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"collect","slug":"collect","permalink":"/tags/collect/"},{"name":"script","slug":"script","permalink":"/tags/script/"},{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Grunt jshint 配置","slug":"grunt-jshint-options","date":"2017-10-27T04:45:52.000Z","updated":"2017-11-02T14:41:08.784Z","comments":true,"path":"2017/10/27/grunt-jshint-options/","link":"","permalink":"/2017/10/27/grunt-jshint-options/","excerpt":"","text":"jsHint 同 jsLint 一样都是 js 代码检查工具 jsHint 规则 参考资料http://www.cnblogs.com/code/articles/4103070.htmlhttp://www.htmlhifive.com/conts/web/view/library/JSLint_JSHint bitwise1// 禁用位运算符(如^，&amp;) curly1// if 和 while 等语句中使用&#123;&#125;来明确代码块 eqeqeq1// 使用 === 和 !== 替代 == 和 != forin1// 在 for in 循环中使用 Object.prototype.hasOwnProperty() 来过滤原型链中的属性 immed123456789// 匿名函数调用必须(function() &#123; // body &#125;());// 而不是(function() &#123; // body&#125;)();// 这是为了表明，表达式的值是函数的结果，而不是函数本身。 latedef1// 变量定义前禁止使用 newcap1// 构造函数名首字母必须大写 noarg1// 禁止使用arguments.caller和arguments.callee noempty1// 禁止出现空的代码块 nonew1// 禁止使用构造器 plusplus1// 禁止使用++和-- undef1// 禁止使用不在全局变量列表中的未定义的变量 strict1// 强制使用ES5的严格模式 freeze1234// 禁止复写原生对象(如Array, Date)的原型/* jshint freeze:true */Array.prototype.count = function (value) &#123; return 4; &#125;;// -&gt; Warning: Extending prototype of native object: &apos;Array&apos;. asi1// 允许省略分号 boss1// 允许在if，for，while语句中使用赋值;在条件语句中使用赋值经常是笔误if (a = 10) &#123;&#125; debug1// 允许debugger语句 eqnull12// 允许==null// ==null通常用来比较=== null;=== undefined evil1// 允许使用eval expr1// 允许应该出现赋值或函数调用的地方使用表达式 iterator12// 允许__iterator__;// 不是所有的浏览器都支持__iterator__。 lastsemic12// 允许单行控制块省略分号var name = (function() &#123; return &apos;Anton&apos; &#125;()); laxbreak1// 允许不安全的行中断(与laxcomma配合使用) laxcomma1// 允许逗号开头的编码样式 loopfunc1// 允许循环中定义函数 onecase1// 允许只有一个case条件的switch语句吗 proto1// 允许 proto（不是所有的浏览器都支持__proto__.） regexdash1// 在正则表达式的控制语句，连字符开头或方括号的结束 - 容忍的存在。 scripturl1// 允许 javascript:; shadow1234567891011// 允许变量shadowfunction test() &#123; var x = 10; if (true) &#123; var x = 20; &#125; return x;&#125;// 基于“函数作用域”，多次定义变量和单次定义是没有区别的，但是会造成阅读障碍。 sub12// 允许person[‘name’]// JSHint推荐使用 person.name 代替 person[‘name’] supernew1// 允许new function() &#123;…&#125;和new Object; validthis1// 允许严格模式下在非构造函数中使用this","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"plugin","slug":"plugin","permalink":"/tags/plugin/"},{"name":"grunt","slug":"grunt","permalink":"/tags/grunt/"},{"name":"script","slug":"script","permalink":"/tags/script/"}]},{"title":"Markdown 语言学习","slug":"markdown-course","date":"2017-10-26T14:17:29.000Z","updated":"2017-11-02T14:40:22.120Z","comments":true,"path":"2017/10/26/markdown-course/","link":"","permalink":"/2017/10/26/markdown-course/","excerpt":"","text":"Markdown 的目标是实现「易读易写」。 Markdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强。 建议使用缩进表示归属上一层级，如果出现块情况非空行不能处理归属问题 标题123456H1 :# Header 1H2 :## Header 2H3 :### Header 3H4 :#### Header 4H5 :##### Header 5H6 :###### Header 6 H1 :# Header 1H2 :## Header 2H3 :### Header 3H4 :#### Header 4H5 :##### Header 5H6 :###### Header 6 文本样式123456789101112（带“*”星号的文本样式，在原版 Markdown 标准中不存在，但在其大部分衍生标准中被添加）链接 :[Title](URL)加粗 :**Bold**斜体字 :*Italics**删除线 :~~text~~*高亮 :==text==段落 : 段落之间空一行换行符 : 一行结束时输入两个空格列表 :* 添加星号成为一个新的列表项。引用 :&gt; 引用内容内嵌代码 : `alert(&apos;Hello World&apos;);`画水平线 (HR) :-------- 链接 :Title加粗 :Bold斜体字 :Italics删除线 :text 高亮 :==text==段落 : 段落之间空一行换行符 : 一行结束时输入两个空格列表 :* 添加星号成为一个新的列表项。引用 :&gt; 引用内容内嵌代码 : alert(&#39;Hello World&#39;);画水平线 (HR) :——– 图片1![Title](src). 写代码1连续3个【`】闭合，闭合部分写入代码 HTML 代码在 HTML 区块标签间的 Markdown 格式语法将不会被处理。处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换 符号 输入 &amp; &amp;amp; &gt; &amp;gt; &lt; &amp;lt; 区块引用 Blockquotes12345678&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt;&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing.&gt;&gt; Back to the first level. This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. Back to the first level. 列表12345无序列表使用星号、加号或是减号作为列表标记* Red // eq: + Red - Red* Green Light* Blue Red GreenLight Blue 123456有序列表则使用数字接着一个英文句点很重要的一点是，列表标记上使用的数字并不会影响输出的 HTML 结果为未来考虑，建议保留顺序1. Bird2. McHale3. Parish Bird McHale Parish 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;p&gt; 标签包起来123* Bird* Magic 当然，项目列表很可能会不小心产生，像是下面这样的写法：11986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。11986\\. What a great season. 表格12345| Tables | Col | Type || ------------- |:-------------:| -----:|| SA_User | Type | int || SA_Role | RoleName | char || SA_UserRole | UserId | 1 | Tables Col Type SA_User Type int SA_Role RoleName char SA_UserRole UserId 1 自动链接12一般网址的链接文字就和链接地址一样&lt;http://example.com/&gt; 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），可以在星号的前面加上反斜杠：1\\*literal asterisks\\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"script","slug":"script","permalink":"/tags/script/"},{"name":"md","slug":"md","permalink":"/tags/md/"}]},{"title":"YMAL 语言学习","slug":"yaml-course","date":"2017-10-26T14:17:21.000Z","updated":"2017-11-02T14:42:44.424Z","comments":true,"path":"2017/10/26/yaml-course/","link":"","permalink":"/2017/10/26/yaml-course/","excerpt":"","text":"参考：阮一峰的网络日志 - YAML 语言教程 YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便，也类似于标准通用标记语言的子集XML的数据描述语言，语法比XML简单很多。 YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。 基本语法 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可1# 表示注释，从这个字符一直到行尾，都会被解析器忽略。 数据结构 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 比对 YAML 和 JavascriptYAML 转换 Javascript 对象的一组键值对，使用冒号结构表示。 12345animal: petsout~ &#123; animal: &apos;pets&apos; &#125;# 行内对象hash: &#123; name: Steve, foo: bar &#125;out~ &#123; hash: &#123; name: &apos;Steve&apos;, foo: &apos;bar&apos; &#125; &#125; 一组连词线开头的行，构成一个数组。 12345678910111213- Cat- Dog- Goldfishout~ [ &apos;Cat&apos;, &apos;Dog&apos;, &apos;Goldfish&apos; ]# 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。- - Cat - Dog - Goldfishout~ [ [ &apos;Cat&apos;, &apos;Dog&apos;, &apos;Goldfish&apos; ] ]# 行内表示法animal: [Cat, Dog]out~ &#123; animal: [ &apos;Cat&apos;, &apos;Dog&apos; ] &#125; 对象和数组可以结合使用，形成复合结构 123456789languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 123456&#123; languages: [ &apos;Ruby&apos;, &apos;Perl&apos;, &apos;Python&apos; ], websites: &#123; YAML: &apos;yaml.org&apos;, Ruby: &apos;ruby-lang.org&apos;, Python: &apos;python.org&apos;, Perl: &apos;use.perl.org&apos; &#125; &#125; 纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。 字符串 - 字符串默认不使用引号表示。 布尔值 - 布尔值用true和false表示 整数 - 数值直接以字面量的形式表示 浮点数 Null - # null用~表示 时间 - 时间采用 ISO8601 格式 日期 - 日期采用复合 iso8601 格式的年、月、日表示。 使用两个感叹号，强制转换数据类型 12e: !!str 123f: !!str true 字符串字符串是最常见，也是最复杂的一种数据类型。 123# 字符串默认不使用引号表示。str: 这是一行字符串out~ &#123; str: &apos;这是一行字符串&apos; &#125; 123# 如果字符串之中包含空格或特殊字符，需要放在引号之中。str: &apos;内容： 字符串&apos;out~ &#123; str: &apos;内容: 字符串&apos; &#125; 1234# 单引号和双引号都可以使用，双引号不会对特殊字符转义。s1: &apos;内容\\n字符串&apos;s2: &quot;内容\\n字符串&quot;out~ &#123; s1: &apos;内容\\\\n字符串&apos;, s2: &apos;内容\\n字符串&apos; &#125; 123# 单引号之中如果还有单引号，必须连续使用两个单引号转义。str: &apos;labor&apos;&apos;s day&apos;out~ &#123; str: &apos;labor\\&apos;s day&apos; &#125; 12345# 字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。str: 这是一段 多行 字符串out~ &#123; str: &apos;这是一段 多行 字符串&apos; &#125; 12345678# 多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行。this: | Foo Barthat: &gt; Foo Barout~ &#123; this: &apos;Foo\\nBar\\n&apos;, that: &apos;Foo Bar\\n&apos; &#125; 1234567891011# +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。s1: | Foos2: |+ Foos3: |- Fooout~ &#123; s1: &apos;Foo\\n&apos;, s2: &apos;Foo\\n\\n\\n&apos;, s3: &apos;Foo&apos; &#125; 1234567# 字符串之中可以插入 HTML 标记。message: | &lt;p style=&quot;color: red&quot;&gt; 段落 &lt;/p&gt;out~ &#123; message: &apos;\\n&lt;p style=&quot;color: red&quot;&gt;\\n 段落\\n&lt;/p&gt;\\n&apos; &#125; 引用锚点&amp;和别名*，可以用来引用 1234567891011defaults: &amp;defaults adapter: postgres host: localhostdevelopment: database: myapp_development &lt;&lt;: *defaultstest: database: myapp_test &lt;&lt;: *defaults &amp;用来建立锚点（defaults），&lt;&lt;表示合并到当前数据，*用来引用锚点。等同于 12345678910111213defaults: adapter: postgres host: localhostdevelopment: database: myapp_development adapter: postgres host: localhosttest: database: myapp_test adapter: postgres host: localhost 另一种写法： 12345- &amp;showell Steve - Clark - Brian - Oren - *showell 等同于 1[ &apos;Steve&apos;, &apos;Clark&apos;, &apos;Brian&apos;, &apos;Oren&apos;, &apos;Steve&apos; ]","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"script","slug":"script","permalink":"/tags/script/"},{"name":"ymal","slug":"ymal","permalink":"/tags/ymal/"}]},{"title":"hexo themes (2)","slug":"hexo-themes-2","date":"2017-10-25T15:03:48.000Z","updated":"2017-11-02T14:42:02.210Z","comments":true,"path":"2017/10/25/hexo-themes-2/","link":"","permalink":"/2017/10/25/hexo-themes-2/","excerpt":"","text":"安装模板遇到的问题网络安装模块因网络原因导致失败，也有可能是资源已经关闭（可能性不高） themes/.config.yml每个模板都会有自己的配置，与博客自己的 _config.yml 不一样，此配置文件只对模板起作用，因不了解，导致 less 生成 css 文件失败 .config.yml1languages: zh-CN # 使用不存在的语言 zh，导致内部调用 ca themes/languages因配置错误语言，发现 ejs 具体调用语言方法，具体待进一步去学习1__(&apos;index.category&apos;) # 估计是读取 languages yml 配置的 index.category 变量值 node_modules模块脚本等资源都可以直接修改，因发现 hexo-asset-image 模块生产图片路径有误，直接修改 index.js 文件处理脚本部分问题后，可正确输出图片 多级 categories在 md 文件的 categories 写入数组，将按照数组顺序建立层级关系1234categories: # parent &gt;&gt; child &gt;&gt; tail - parent - child - tail","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"theme","slug":"theme","permalink":"/tags/theme/"}]},{"title":"一张图简述 MIT 等协议","slug":"about-license-for-simple","date":"2017-10-25T14:08:27.000Z","updated":"2017-11-02T14:45:11.530Z","comments":true,"path":"2017/10/25/about-license-for-simple/","link":"","permalink":"/2017/10/25/about-license-for-simple/","excerpt":"","text":"License世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种—-GPL、BSD、MIT、Mozilla、Apache和LGPL—-之中做选择，也很复杂，这张图比那种一堆文字要简单易懂的多 引用：如何选择开源许可证？","categories":[{"name":"license","slug":"license","permalink":"/categories/license/"}],"tags":[{"name":"collect","slug":"collect","permalink":"/tags/collect/"}]},{"title":"hexo theme","slug":"hexo-themes","date":"2017-10-25T03:53:52.000Z","updated":"2017-11-02T14:41:57.100Z","comments":true,"path":"2017/10/25/hexo-themes/","link":"","permalink":"/2017/10/25/hexo-themes/","excerpt":"","text":"官网提供的模板模板地址 hexo themes，点击图片可以预览效果，点击文字可以进入 git下面列举示例，引用 hexo-theme-bootstrap-blog 安装主题必须在 hexo 2.4 或以上 将主题拉到本地: 1$ git clone https://github.com/cgmartin/hexo-theme-bootstrap-blog.git themes/bootstrap-blog 安装 hexo-tag-bootstrap for more Bootstrap tags (textcolors, buttons, labels, badges, etc.): 1$ npm install hexo-tag-bootstrap --save 安装 hexo-tag-fontawesome for placing Font Awesome icons in your Markdown: 1$ npm install hexo-tag-fontawesome --save 修改脚本引用因 google 国内无法访问，打开 themes/bootstrap-blog/layout/_partial/inline-scripts.ejs，将 jQuery 和 bootstrap 引用修改： 123&lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 配置 _config.yml 的 theme 配置 1234theme: hexo-theme-xups# 更新 git$ cd themes/bootstrap-blog$ git pull","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"theme","slug":"theme","permalink":"/tags/theme/"}]},{"title":"hexo 安装","slug":"hexo-install","date":"2017-10-25T03:05:14.000Z","updated":"2017-11-02T14:41:43.329Z","comments":true,"path":"2017/10/25/hexo-install/","link":"","permalink":"/2017/10/25/hexo-install/","excerpt":"","text":"hexo 环境node.js &amp; npm到官网下载最新安装包 node.js，已经包括 node.js 和 npm，默认安装便可 git到官网下载最新安装包 git，安装后一定要重启，否则 git 无法作为全局命令使用（弄了N次环境变量都不行，结果重启一下就好了，晕死） hexo 直接给命令12345$ npm install hexo-cli -g # 作为全局命令安装 hexo $ hexo init blog # 通过 cd 命令选定目录后初始化建立 blog$ cd blog # 进入 blog 目录$ npm install # 还原 npm 引用$ hexo server # 启动 hexo 服务，默认4000端口 发布 git 静态页面 配置github账户信息 12$ git config --global user.name &quot;YourName&quot; $ git config --global user.email &quot;YourEmail&quot; SSH进入 blog 所在目录，右键打开“Git Bash Here” 1234$ ssh-keygen -t rsa -C &quot;youremail&quot; # 第一个提示信息是 .ssh 目录，直接回车 # 第二、三个提示是输入密匙，两次一致便可$ cd ~/.ssh # 进入 SSH 目录$ cat id_rsa.pub # SSH 密匙，复制并在 git 上面添加（注意不要复制最后的邮件地址） git 配置在参考 hexo从零开始到搭建完整 及个人博客 首个博客","categories":[{"name":"tool","slug":"tool","permalink":"/categories/tool/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"install","slug":"install","permalink":"/tags/install/"}]},{"title":"首个博客","slug":"first-blog","date":"2017-10-24T15:11:14.000Z","updated":"2017-11-02T15:04:36.939Z","comments":true,"path":"2017/10/24/first-blog/","link":"","permalink":"/2017/10/24/first-blog/","excerpt":"","text":"首次发布个人博客尝试学习 node.js 搭建服务端，学习 hexo + node.js 开源项目创建个人博客，初步了解该项目使用技术有 技术 介绍 node.js 一个Javascript运行环境(runtime)；Node.js 使用事件驱动，非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 git 分布式版本控制系统 YAML _config.yml另一种标记语言，它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。 ejs EJS是一个JavaScript模板库，用来从JSON数据中生成HTML字符串。 md Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 终于成功搭建 hexo坑坑坑….. 稍微总结一下 hexo 搭建遇到的问题 搭建了两个网站，结果配置 _config.yml 的 deploy 搞混了 顺带说明一下变量和值之间的冒号“:”必须在冒号后添加一个空格，语法要求 创建 SSH 命令注意要大小写匹配安装 1$ ssh-keygen -t rsa -C &quot;youremail&quot; # 配置 ssh 安装 hexo-deployer-git 若失败或提示忽略这忽略那，建议删除 node_modules 目录，重新执行 npm install 12$ npm install hexo-deployer-git --save$ npm install 下一步掌握 _config.yml 配置文件及安装 themes","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"/tags/blog/"}]}]}